{"version":3,"file":"stringify-CDcTTVEr.js","sources":["../../node_modules/lossless-json/lib/esm/utils.js","../../node_modules/lossless-json/lib/esm/LosslessNumber.js","../../node_modules/lossless-json/lib/esm/numberParsers.js","../../node_modules/lossless-json/lib/esm/revive.js","../../node_modules/lossless-json/lib/esm/parse.js","../../node_modules/lossless-json/lib/esm/stringify.js"],"sourcesContent":["/**\n * Test whether a string contains an integer number\n */\nexport function isInteger(value) {\n  return INTEGER_REGEX.test(value);\n}\nconst INTEGER_REGEX = /^-?[0-9]+$/;\n\n/**\n * Test whether a string contains a number\n * http://stackoverflow.com/questions/13340717/json-numbers-regular-expression\n */\nexport function isNumber(value) {\n  return NUMBER_REGEX.test(value);\n}\nconst NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/;\n\n/**\n * Test whether a string can be safely represented with a number\n * without information loss.\n *\n * When approx is true, floating point numbers that lose a few digits but\n * are still approximately equal in value are considered safe too.\n * Integer numbers must still be exactly equal.\n */\nexport function isSafeNumber(value, config) {\n  const num = parseFloat(value);\n  const str = String(num);\n  const v = extractSignificantDigits(value);\n  const s = extractSignificantDigits(str);\n  if (v === s) {\n    return true;\n  }\n  if (config?.approx === true) {\n    // A value is approximately equal when:\n    // 1. it is a floating point number, not an integer\n    // 2. it has at least 14 digits\n    // 3. the first 14 digits are equal\n    const requiredDigits = 14;\n    if (!isInteger(value) && s.length >= requiredDigits && v.startsWith(s.substring(0, requiredDigits))) {\n      return true;\n    }\n  }\n  return false;\n}\nexport let UnsafeNumberReason = /*#__PURE__*/function (UnsafeNumberReason) {\n  UnsafeNumberReason[\"underflow\"] = \"underflow\";\n  UnsafeNumberReason[\"overflow\"] = \"overflow\";\n  UnsafeNumberReason[\"truncate_integer\"] = \"truncate_integer\";\n  UnsafeNumberReason[\"truncate_float\"] = \"truncate_float\";\n  return UnsafeNumberReason;\n}({});\n\n/**\n * When the provided value is an unsafe number, describe what the reason is:\n * overflow, underflow, truncate_integer, or truncate_float.\n * Returns undefined when the value is safe.\n */\nexport function getUnsafeNumberReason(value) {\n  if (isSafeNumber(value, {\n    approx: false\n  })) {\n    return undefined;\n  }\n  if (isInteger(value)) {\n    return UnsafeNumberReason.truncate_integer;\n  }\n  const num = parseFloat(value);\n  if (!isFinite(num)) {\n    return UnsafeNumberReason.overflow;\n  }\n  if (num === 0) {\n    return UnsafeNumberReason.underflow;\n  }\n  return UnsafeNumberReason.truncate_float;\n}\n\n/**\n * Convert a string into a number when it is safe to do so.\n * Throws an error otherwise, explaining the reason.\n */\nexport function toSafeNumberOrThrow(value, config) {\n  const number = parseFloat(value);\n  const unsafeReason = getUnsafeNumberReason(value);\n  if (config?.approx === true ? unsafeReason && unsafeReason !== UnsafeNumberReason.truncate_float : unsafeReason) {\n    const unsafeReasonText = unsafeReason?.replace(/_\\w+$/, '');\n    throw new Error('Cannot safely convert to number: ' + `the value '${value}' would ${unsafeReasonText} and become ${number}`);\n  }\n  return number;\n}\n\n/**\n * Get the significant digits of a number.\n *\n * For example:\n *   '2.34' returns '234'\n *   '-77' returns '77'\n *   '0.003400' returns '34'\n *   '120.5e+30' returns '1205'\n **/\nexport function extractSignificantDigits(value) {\n  return value\n  // from \"-0.250e+30\" to \"-0.250\"\n  .replace(EXPONENTIAL_PART_REGEX, '')\n\n  // from \"-0.250\" to \"-0250\"\n  .replace(DOT_REGEX, '')\n\n  // from \"-0250\" to \"-025\"\n  .replace(TRAILING_ZEROS_REGEX, '')\n\n  // from \"-025\" to \"25\"\n  .replace(LEADING_MINUS_AND_ZEROS_REGEX, '');\n}\nconst EXPONENTIAL_PART_REGEX = /[eE][+-]?\\d+$/;\nconst LEADING_MINUS_AND_ZEROS_REGEX = /^-?(0*)?/;\nconst DOT_REGEX = /\\./;\nconst TRAILING_ZEROS_REGEX = /0+$/;\n//# sourceMappingURL=utils.js.map","import { extractSignificantDigits, getUnsafeNumberReason, isInteger, isNumber, UnsafeNumberReason } from './utils.js';\n\n/**\n * A lossless number. Stores its numeric value as string\n */\nexport class LosslessNumber {\n  // numeric value as string\n\n  // type information\n  isLosslessNumber = true;\n  constructor(value) {\n    if (!isNumber(value)) {\n      throw new Error('Invalid number (value: \"' + value + '\")');\n    }\n    this.value = value;\n  }\n\n  /**\n   * Get the value of the LosslessNumber as number or bigint.\n   *\n   * - a number is returned for safe numbers and decimal values that only lose some insignificant digits\n   * - a bigint is returned for big integer numbers\n   * - an Error is thrown for values that will overflow or underflow\n   *\n   * Note that you can implement your own strategy for conversion by just getting the value as string\n   * via .toString(), and using util functions like isInteger, isSafeNumber, getUnsafeNumberReason,\n   * and toSafeNumberOrThrow to convert it to a numeric value.\n   */\n  valueOf() {\n    const unsafeReason = getUnsafeNumberReason(this.value);\n\n    // safe or truncate_float\n    if (unsafeReason === undefined || unsafeReason === UnsafeNumberReason.truncate_float) {\n      return parseFloat(this.value);\n    }\n\n    // truncate_integer\n    if (isInteger(this.value)) {\n      return BigInt(this.value);\n    }\n\n    // overflow or underflow\n    throw new Error('Cannot safely convert to number: ' + `the value '${this.value}' would ${unsafeReason} and become ${parseFloat(this.value)}`);\n  }\n\n  /**\n   * Get the value of the LosslessNumber as string.\n   */\n  toString() {\n    return this.value;\n  }\n\n  // Note: we do NOT implement a .toJSON() method, and you should not implement\n  // or use that, it cannot safely turn the numeric value in the string into\n  // stringified JSON since it has to be parsed into a number first.\n}\n\n/**\n * Test whether a value is a LosslessNumber\n */\nexport function isLosslessNumber(value) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return value && typeof value === 'object' && value.isLosslessNumber === true || false;\n}\n\n/**\n * Convert a number into a LosslessNumber if this is possible in a safe way\n * If the value has too many digits, or is NaN or Infinity, an error will be thrown\n */\nexport function toLosslessNumber(value) {\n  if (extractSignificantDigits(value + '').length > 15) {\n    throw new Error('Invalid number: contains more than 15 digits and is most likely truncated and unsafe by itself ' + `(value: ${value})`);\n  }\n  if (isNaN(value)) {\n    throw new Error('Invalid number: NaN');\n  }\n  if (!isFinite(value)) {\n    throw new Error('Invalid number: ' + value);\n  }\n  return new LosslessNumber(String(value));\n}\n//# sourceMappingURL=LosslessNumber.js.map","import { LosslessNumber } from './LosslessNumber.js';\nimport { isInteger } from './utils.js';\nexport function parseLosslessNumber(value) {\n  return new LosslessNumber(value);\n}\nexport function parseNumberAndBigInt(value) {\n  return isInteger(value) ? BigInt(value) : parseFloat(value);\n}\n//# sourceMappingURL=numberParsers.js.map","import { isLosslessNumber } from './LosslessNumber.js';\n/**\n * Revive a json object.\n * Applies the reviver function recursively on all values in the JSON object.\n * @param json   A JSON Object, Array, or value\n * @param reviver\n *              A reviver function invoked with arguments `key` and `value`,\n *              which must return a replacement value. The function context\n *              (`this`) is the Object or Array that contains the currently\n *              handled value.\n */\nexport function revive(json, reviver) {\n  return reviveValue({\n    '': json\n  }, '', json, reviver);\n}\n\n/**\n * Revive a value\n */\nfunction reviveValue(context, key, value, reviver) {\n  if (Array.isArray(value)) {\n    return reviver.call(context, key, reviveArray(value, reviver));\n  } else if (value && typeof value === 'object' && !isLosslessNumber(value)) {\n    // note the special case for LosslessNumber,\n    // we don't want to iterate over the internals of a LosslessNumber\n    return reviver.call(context, key, reviveObject(value, reviver));\n  } else {\n    return reviver.call(context, key, value);\n  }\n}\n\n/**\n * Revive the properties of an object\n */\nfunction reviveObject(object, reviver) {\n  Object.keys(object).forEach(key => {\n    const value = reviveValue(object, key, object[key], reviver);\n    if (value !== undefined) {\n      object[key] = value;\n    } else {\n      delete object[key];\n    }\n  });\n  return object;\n}\n\n/**\n * Revive the properties of an Array\n */\nfunction reviveArray(array, reviver) {\n  for (let i = 0; i < array.length; i++) {\n    array[i] = reviveValue(array, i + '', array[i], reviver);\n  }\n  return array;\n}\n//# sourceMappingURL=revive.js.map","import { parseLosslessNumber } from './numberParsers.js';\nimport { revive } from './revive.js';\n/**\n * The LosslessJSON.parse() method parses a string as JSON, optionally transforming\n * the value produced by parsing.\n *\n * The parser is based on the parser of Tan Li Hou shared in\n * https://lihautan.com/json-parser-with-javascript/\n *\n * @param text\n * The string to parse as JSON. See the JSON object for a description of JSON syntax.\n *\n * @param [reviver]\n * If a function, prescribes how the value originally produced by parsing is\n * transformed, before being returned.\n *\n * @param [parseNumber=parseLosslessNumber]\n * Pass a custom number parser. Input is a string, and the output can be unknown\n * numeric value: number, bigint, LosslessNumber, or a custom BigNumber library.\n *\n * @returns Returns the Object corresponding to the given JSON text.\n *\n * @throws Throws a SyntaxError exception if the string to parse is not valid JSON.\n */\nexport function parse(text, reviver) {\n  let parseNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : parseLosslessNumber;\n  let i = 0;\n  const value = parseValue();\n  expectValue(value);\n  expectEndOfInput();\n  return reviver ? revive(value, reviver) : value;\n  function parseObject() {\n    if (text.charCodeAt(i) === codeOpeningBrace) {\n      i++;\n      skipWhitespace();\n      const object = {};\n      let initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\n        if (!initial) {\n          eatComma();\n          skipWhitespace();\n        } else {\n          initial = false;\n        }\n        const start = i;\n        const key = parseString();\n        if (key === undefined) {\n          throwObjectKeyExpected();\n          return; // To make TS happy\n        }\n        skipWhitespace();\n        eatColon();\n        const value = parseValue();\n        if (value === undefined) {\n          throwObjectValueExpected();\n          return; // To make TS happy\n        }\n\n        // TODO: test deep equal instead of strict equal\n        if (Object.prototype.hasOwnProperty.call(object, key) && !isDeepEqual(value, object[key])) {\n          // Note that we could also test `if(key in object) {...}`\n          // or `if (object[key] !== 'undefined') {...}`, but that is slower.\n          throwDuplicateKey(key, start + 1);\n        }\n        object[key] = value;\n      }\n      if (text.charCodeAt(i) !== codeClosingBrace) {\n        throwObjectKeyOrEndExpected();\n      }\n      i++;\n      return object;\n    }\n  }\n  function parseArray() {\n    if (text.charCodeAt(i) === codeOpeningBracket) {\n      i++;\n      skipWhitespace();\n      const array = [];\n      let initial = true;\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\n        if (!initial) {\n          eatComma();\n        } else {\n          initial = false;\n        }\n        const value = parseValue();\n        expectArrayItem(value);\n        array.push(value);\n      }\n      if (text.charCodeAt(i) !== codeClosingBracket) {\n        throwArrayItemOrEndExpected();\n      }\n      i++;\n      return array;\n    }\n  }\n  function parseValue() {\n    skipWhitespace();\n    const value = parseString() ?? parseNumeric() ?? parseObject() ?? parseArray() ?? parseKeyword('true', true) ?? parseKeyword('false', false) ?? parseKeyword('null', null);\n    skipWhitespace();\n    return value;\n  }\n  function parseKeyword(name, value) {\n    if (text.slice(i, i + name.length) === name) {\n      i += name.length;\n      return value;\n    }\n  }\n  function skipWhitespace() {\n    while (isWhitespace(text.charCodeAt(i))) {\n      i++;\n    }\n  }\n  function parseString() {\n    if (text.charCodeAt(i) === codeDoubleQuote) {\n      i++;\n      let result = '';\n      while (i < text.length && text.charCodeAt(i) !== codeDoubleQuote) {\n        if (text.charCodeAt(i) === codeBackslash) {\n          const char = text[i + 1];\n          const escapeChar = escapeCharacters[char];\n          if (escapeChar !== undefined) {\n            result += escapeChar;\n            i++;\n          } else if (char === 'u') {\n            if (isHex(text.charCodeAt(i + 2)) && isHex(text.charCodeAt(i + 3)) && isHex(text.charCodeAt(i + 4)) && isHex(text.charCodeAt(i + 5))) {\n              result += String.fromCharCode(parseInt(text.slice(i + 2, i + 6), 16));\n              i += 5;\n            } else {\n              throwInvalidUnicodeCharacter(i);\n            }\n          } else {\n            throwInvalidEscapeCharacter(i);\n          }\n        } else {\n          if (isValidStringCharacter(text.charCodeAt(i))) {\n            result += text[i];\n          } else {\n            throwInvalidCharacter(text[i]);\n          }\n        }\n        i++;\n      }\n      expectEndOfString();\n      i++;\n      return result;\n    }\n  }\n  function parseNumeric() {\n    const start = i;\n    if (text.charCodeAt(i) === codeMinus) {\n      i++;\n      expectDigit(start);\n    }\n    if (text.charCodeAt(i) === codeZero) {\n      i++;\n    } else if (isNonZeroDigit(text.charCodeAt(i))) {\n      i++;\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeDot) {\n      i++;\n      expectDigit(start);\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\n      i++;\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\n        i++;\n      }\n      expectDigit(start);\n      while (isDigit(text.charCodeAt(i))) {\n        i++;\n      }\n    }\n    if (i > start) {\n      return parseNumber(text.slice(start, i));\n    }\n  }\n  function eatComma() {\n    if (text.charCodeAt(i) !== codeComma) {\n      throw new SyntaxError(`Comma ',' expected after value ${gotAt()}`);\n    }\n    i++;\n  }\n  function eatColon() {\n    if (text.charCodeAt(i) !== codeColon) {\n      throw new SyntaxError(`Colon ':' expected after property name ${gotAt()}`);\n    }\n    i++;\n  }\n  function expectValue(value) {\n    if (value === undefined) {\n      throw new SyntaxError(`JSON value expected ${gotAt()}`);\n    }\n  }\n  function expectArrayItem(value) {\n    if (value === undefined) {\n      throw new SyntaxError(`Array item expected ${gotAt()}`);\n    }\n  }\n  function expectEndOfInput() {\n    if (i < text.length) {\n      throw new SyntaxError(`Expected end of input ${gotAt()}`);\n    }\n  }\n  function expectDigit(start) {\n    if (!isDigit(text.charCodeAt(i))) {\n      const numSoFar = text.slice(start, i);\n      throw new SyntaxError(`Invalid number '${numSoFar}', expecting a digit ${gotAt()}`);\n    }\n  }\n  function expectEndOfString() {\n    if (text.charCodeAt(i) !== codeDoubleQuote) {\n      throw new SyntaxError(`End of string '\"' expected ${gotAt()}`);\n    }\n  }\n  function throwObjectKeyExpected() {\n    throw new SyntaxError(`Quoted object key expected ${gotAt()}`);\n  }\n  function throwDuplicateKey(key, pos) {\n    throw new SyntaxError(`Duplicate key '${key}' encountered at position ${pos}`);\n  }\n  function throwObjectKeyOrEndExpected() {\n    throw new SyntaxError(`Quoted object key or end of object '}' expected ${gotAt()}`);\n  }\n  function throwArrayItemOrEndExpected() {\n    throw new SyntaxError(`Array item or end of array ']' expected ${gotAt()}`);\n  }\n  function throwInvalidCharacter(char) {\n    throw new SyntaxError(`Invalid character '${char}' ${pos()}`);\n  }\n  function throwInvalidEscapeCharacter(start) {\n    const chars = text.slice(start, start + 2);\n    throw new SyntaxError(`Invalid escape character '${chars}' ${pos()}`);\n  }\n  function throwObjectValueExpected() {\n    throw new SyntaxError(`Object value expected after ':' ${pos()}`);\n  }\n  function throwInvalidUnicodeCharacter(start) {\n    const chars = text.slice(start, start + 6);\n    throw new SyntaxError(`Invalid unicode character '${chars}' ${pos()}`);\n  }\n\n  // zero based character position\n  function pos() {\n    return `at position ${i}`;\n  }\n  function got() {\n    return i < text.length ? `but got '${text[i]}'` : 'but reached end of input';\n  }\n  function gotAt() {\n    return got() + ' ' + pos();\n  }\n}\nfunction isWhitespace(code) {\n  return code === codeSpace || code === codeNewline || code === codeTab || code === codeReturn;\n}\nfunction isHex(code) {\n  return code >= codeZero && code <= codeNine || code >= codeUppercaseA && code <= codeUppercaseF || code >= codeLowercaseA && code <= codeLowercaseF;\n}\nfunction isDigit(code) {\n  return code >= codeZero && code <= codeNine;\n}\nfunction isNonZeroDigit(code) {\n  return code >= codeOne && code <= codeNine;\n}\nexport function isValidStringCharacter(code) {\n  return code >= 0x20 && code <= 0x10ffff;\n}\nexport function isDeepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    return a.length === b.length && a.every((item, index) => isDeepEqual(item, b[index]));\n  }\n  if (isObject(a) && isObject(b)) {\n    const keys = [...new Set([...Object.keys(a), ...Object.keys(b)])];\n    return keys.every(key => isDeepEqual(a[key], b[key]));\n  }\n  return false;\n}\nfunction isObject(value) {\n  return typeof value === 'object' && value !== null;\n}\n\n// map with all escape characters\nconst escapeCharacters = {\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t'\n  // note that \\u is handled separately in parseString()\n};\nconst codeBackslash = 0x5c; // \"\\\"\nconst codeOpeningBrace = 0x7b; // \"{\"\nconst codeClosingBrace = 0x7d; // \"}\"\nconst codeOpeningBracket = 0x5b; // \"[\"\nconst codeClosingBracket = 0x5d; // \"]\"\nconst codeSpace = 0x20; // \" \"\nconst codeNewline = 0xa; // \"\\n\"\nconst codeTab = 0x9; // \"\\t\"\nconst codeReturn = 0xd; // \"\\r\"\nconst codeDoubleQuote = 0x0022; // \"\nconst codePlus = 0x2b; // \"+\"\nconst codeMinus = 0x2d; // \"-\"\nconst codeZero = 0x30;\nconst codeOne = 0x31;\nconst codeNine = 0x39;\nconst codeComma = 0x2c; // \",\"\nconst codeDot = 0x2e; // \".\" (dot, period)\nconst codeColon = 0x3a; // \":\"\nexport const codeUppercaseA = 0x41; // \"A\"\nexport const codeLowercaseA = 0x61; // \"a\"\nexport const codeUppercaseE = 0x45; // \"E\"\nexport const codeLowercaseE = 0x65; // \"e\"\nexport const codeUppercaseF = 0x46; // \"F\"\nexport const codeLowercaseF = 0x66; // \"f\"\n//# sourceMappingURL=parse.js.map","import { isNumber } from './utils.js';\n\n/**\n * The LosslessJSON.stringify() method converts a JavaScript value to a JSON string,\n * optionally replacing values if a replacer function is specified, or\n * optionally including only the specified properties if a replacer array is specified.\n *\n * @param value\n * The value to convert to a JSON string.\n *\n * @param [replacer]\n * A function that alters the behavior of the stringification process,\n * or an array of String and Number objects that serve as a whitelist for\n * selecting the properties of the value object to be included in the JSON string.\n * If this value is null or not provided, all properties of the object are\n * included in the resulting JSON string.\n *\n * @param [space]\n * A String or Number object that's used to insert white space into the output\n * JSON string for readability purposes. If this is a Number, it indicates the\n * number of space characters to use as white space; this number is capped at 10\n * if it's larger than that. Values less than 1 indicate that no space should be\n * used. If this is a String, the string (or the first 10 characters of the string,\n * if it's longer than that) is used as white space. If this parameter is not\n * provided (or is null), no white space is used.\n *\n * @param [numberStringifiers]\n * An optional list with additional number stringifiers, for example to serialize\n * a BigNumber. The output of the function must be valid stringified JSON.\n * When `undefined` is returned, the property will be deleted from the object.\n * The difference with using a `replacer` is that the output of a `replacer`\n * must be JSON and will be stringified afterwards, whereas the output of the\n * `numberStringifiers` is already stringified JSON.\n *\n * @returns Returns the string representation of the JSON object.\n */\nexport function stringify(value, replacer, space, numberStringifiers) {\n  const resolvedSpace = resolveSpace(space);\n  const replacedValue = typeof replacer === 'function' ? replacer.call({\n    '': value\n  }, '', value) : value;\n  return stringifyValue(replacedValue, '');\n\n  /**\n   * Stringify a value\n   */\n  function stringifyValue(value, indent) {\n    if (Array.isArray(numberStringifiers)) {\n      const stringifier = numberStringifiers.find(item => item.test(value));\n      if (stringifier) {\n        const str = stringifier.stringify(value);\n        if (typeof str !== 'string' || !isNumber(str)) {\n          throw new Error('Invalid JSON number: ' + 'output of a number stringifier must be a string containing a JSON number ' + `(output: ${str})`);\n        }\n        return str;\n      }\n    }\n\n    // boolean, null, number, string, or date\n    if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string' || value === null || value instanceof Date || value instanceof Boolean || value instanceof Number || value instanceof String) {\n      return JSON.stringify(value);\n    }\n\n    // lossless number, the secret ingredient :)\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (value && value.isLosslessNumber) {\n      return value.toString();\n    }\n\n    // BigInt\n    if (typeof value === 'bigint') {\n      return value.toString();\n    }\n\n    // Array\n    if (Array.isArray(value)) {\n      return stringifyArray(value, indent);\n    }\n\n    // Object (test lastly!)\n    if (value && typeof value === 'object') {\n      return stringifyObject(value, indent);\n    }\n    return undefined;\n  }\n\n  /**\n   * Stringify an array\n   */\n  function stringifyArray(array, indent) {\n    if (array.length === 0) {\n      return '[]';\n    }\n    const childIndent = resolvedSpace ? indent + resolvedSpace : undefined;\n    let str = resolvedSpace ? '[\\n' : '[';\n    for (let i = 0; i < array.length; i++) {\n      const item = typeof replacer === 'function' ? replacer.call(array, String(i), array[i]) : array[i];\n      if (resolvedSpace) {\n        str += childIndent;\n      }\n      if (typeof item !== 'undefined' && typeof item !== 'function') {\n        str += stringifyValue(item, childIndent);\n      } else {\n        str += 'null';\n      }\n      if (i < array.length - 1) {\n        str += resolvedSpace ? ',\\n' : ',';\n      }\n    }\n    str += resolvedSpace ? '\\n' + indent + ']' : ']';\n    return str;\n  }\n\n  /**\n   * Stringify an object\n   */\n  function stringifyObject(object, indent) {\n    if (typeof object.toJSON === 'function') {\n      return stringify(object.toJSON(), replacer, space, undefined);\n    }\n    const keys = Array.isArray(replacer) ? replacer.map(String) : Object.keys(object);\n    if (keys.length === 0) {\n      return '{}';\n    }\n    const childIndent = resolvedSpace ? indent + resolvedSpace : undefined;\n    let first = true;\n    let str = resolvedSpace ? '{\\n' : '{';\n    keys.forEach(key => {\n      const value = typeof replacer === 'function' ? replacer.call(object, key, object[key]) : object[key];\n      if (includeProperty(key, value)) {\n        if (first) {\n          first = false;\n        } else {\n          str += resolvedSpace ? ',\\n' : ',';\n        }\n        const keyStr = JSON.stringify(key);\n        str += resolvedSpace ? childIndent + keyStr + ': ' : keyStr + ':';\n        str += stringifyValue(value, childIndent);\n      }\n    });\n    str += resolvedSpace ? '\\n' + indent + '}' : '}';\n    return str;\n  }\n\n  /**\n   * Test whether to include a property in a stringified object or not.\n   */\n  function includeProperty(key, value) {\n    return typeof value !== 'undefined' && typeof value !== 'function' && typeof value !== 'symbol';\n  }\n}\n\n/**\n * Resolve a JSON stringify space:\n * replace a number with a string containing that number of spaces\n */\nfunction resolveSpace(space) {\n  if (typeof space === 'number') {\n    return ' '.repeat(space);\n  }\n  if (typeof space === 'string' && space !== '') {\n    return space;\n  }\n  return undefined;\n}\n//# sourceMappingURL=stringify.js.map"],"names":["isInteger","value","INTEGER_REGEX","isNumber","NUMBER_REGEX","isSafeNumber","config","num","str","v","extractSignificantDigits","s","UnsafeNumberReason","getUnsafeNumberReason","toSafeNumberOrThrow","number","unsafeReason","unsafeReasonText","EXPONENTIAL_PART_REGEX","DOT_REGEX","TRAILING_ZEROS_REGEX","LEADING_MINUS_AND_ZEROS_REGEX","LosslessNumber","__publicField","isLosslessNumber","toLosslessNumber","parseLosslessNumber","parseNumberAndBigInt","revive","json","reviver","reviveValue","context","key","reviveArray","reviveObject","object","array","parse","text","parseNumber","i","parseValue","expectValue","expectEndOfInput","parseObject","codeOpeningBrace","skipWhitespace","initial","codeClosingBrace","eatComma","start","parseString","throwObjectKeyExpected","eatColon","throwObjectValueExpected","isDeepEqual","throwDuplicateKey","throwObjectKeyOrEndExpected","parseArray","codeOpeningBracket","codeClosingBracket","expectArrayItem","throwArrayItemOrEndExpected","parseNumeric","parseKeyword","name","isWhitespace","codeDoubleQuote","result","codeBackslash","char","escapeChar","escapeCharacters","isHex","throwInvalidUnicodeCharacter","throwInvalidEscapeCharacter","isValidStringCharacter","throwInvalidCharacter","expectEndOfString","codeMinus","expectDigit","codeZero","isNonZeroDigit","isDigit","codeDot","codeLowercaseE","codeUppercaseE","codePlus","codeComma","gotAt","codeColon","numSoFar","pos","chars","got","code","codeSpace","codeNewline","codeTab","codeReturn","codeNine","codeUppercaseA","codeUppercaseF","codeLowercaseA","codeLowercaseF","codeOne","a","b","item","index","isObject","stringify","replacer","space","numberStringifiers","resolvedSpace","resolveSpace","replacedValue","stringifyValue","indent","stringifier","stringifyArray","stringifyObject","childIndent","keys","first","includeProperty","keyStr"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}