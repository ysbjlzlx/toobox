import{j as q,P as te}from"./pro-components-DqS1vNmp.js";import{e as Z,J as G,i as F,r as V,aI as re,S as se,Z as ne,B as ae}from"./antd-2qrym3SB.js";import{I as ie}from"./index-d_YuH_AW.js";import{I as oe}from"./InputCopyable-CD5E_uII.js";import"./jsoneditor-EB9WOjbk.js";import"./ContentCopyButton-BjXZ8JlH.js";var J={exports:{}};(function(A,N){(function(C,I){A.exports=I()})(Z,function(){var C={LTS:"h:mm:ss A",LT:"h:mm A",L:"MM/DD/YYYY",LL:"MMMM D, YYYY",LLL:"MMMM D, YYYY h:mm A",LLLL:"dddd, MMMM D, YYYY h:mm A"};return function(I,k,$){var b=k.prototype,l=b.format;$.en.formats=C,b.format=function(p){p===void 0&&(p="YYYY-MM-DDTHH:mm:ssZ");var g=this.$locale().formats,f=function(t,n){return t.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,function(a,r,e){var o=e&&e.toUpperCase();return r||n[e]||C[e]||n[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,function(s,i,c){return i||c.slice(1)})})}(p,g===void 0?{}:g);return l.call(this,f)}}})})(J);var le=J.exports;const ce=G(le);var Q={exports:{}};(function(A,N){(function(C,I){A.exports=I()})(Z,function(){var C={year:0,month:1,day:2,hour:3,minute:4,second:5},I={};return function(k,$,b){var l,p=function(n,a,r){r===void 0&&(r={});var e=new Date(n),o=function(s,i){i===void 0&&(i={});var c=i.timeZoneName||"short",m=s+"|"+c,d=I[m];return d||(d=new Intl.DateTimeFormat("en-US",{hour12:!1,timeZone:s,year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit",timeZoneName:c}),I[m]=d),d}(a,r);return o.formatToParts(e)},g=function(n,a){for(var r=p(n,a),e=[],o=0;o<r.length;o+=1){var s=r[o],i=s.type,c=s.value,m=C[i];m>=0&&(e[m]=parseInt(c,10))}var d=e[3],_=d===24?0:d,v=e[0]+"-"+e[1]+"-"+e[2]+" "+_+":"+e[4]+":"+e[5]+":000",u=+n;return(b.utc(v).valueOf()-(u-=u%1e3))/6e4},f=$.prototype;f.tz=function(n,a){n===void 0&&(n=l);var r=this.utcOffset(),e=this.toDate(),o=e.toLocaleString("en-US",{timeZone:n}),s=Math.round((e-new Date(o))/1e3/60),i=b(o,{locale:this.$L}).$set("millisecond",this.$ms).utcOffset(15*-Math.round(e.getTimezoneOffset()/15)-s,!0);if(a){var c=i.utcOffset();i=i.add(r-c,"minute")}return i.$x.$timezone=n,i},f.offsetName=function(n){var a=this.$x.$timezone||b.tz.guess(),r=p(this.valueOf(),a,{timeZoneName:n}).find(function(e){return e.type.toLowerCase()==="timezonename"});return r&&r.value};var t=f.startOf;f.startOf=function(n,a){if(!this.$x||!this.$x.$timezone)return t.call(this,n,a);var r=b(this.format("YYYY-MM-DD HH:mm:ss:SSS"),{locale:this.$L});return t.call(r,n,a).tz(this.$x.$timezone,!0)},b.tz=function(n,a,r){var e=r&&a,o=r||a||l,s=g(+b(),o);if(typeof n!="string")return b(n).tz(o);var i=function(_,v,u){var h=_-60*v*1e3,y=g(h,u);if(v===y)return[h,v];var w=g(h-=60*(y-v)*1e3,u);return y===w?[h,y]:[_-60*Math.min(y,w)*1e3,Math.max(y,w)]}(b.utc(n,e).valueOf(),s,o),c=i[0],m=i[1],d=b(c).utcOffset(m);return d.$x.$timezone=o,d},b.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone},b.tz.setDefault=function(n){l=n}}})})(Q);var ue=Q.exports;const fe=G(ue);var X={exports:{}};(function(A,N){(function(C,I){A.exports=I()})(Z,function(){var C="minute",I=/[+-]\d\d(?::?\d\d)?/g,k=/([+-]|\d\d)/g;return function($,b,l){var p=b.prototype;l.utc=function(e){var o={date:e,utc:!0,args:arguments};return new b(o)},p.utc=function(e){var o=l(this.toDate(),{locale:this.$L,utc:!0});return e?o.add(this.utcOffset(),C):o},p.local=function(){return l(this.toDate(),{locale:this.$L,utc:!1})};var g=p.parse;p.parse=function(e){e.utc&&(this.$u=!0),this.$utils().u(e.$offset)||(this.$offset=e.$offset),g.call(this,e)};var f=p.init;p.init=function(){if(this.$u){var e=this.$d;this.$y=e.getUTCFullYear(),this.$M=e.getUTCMonth(),this.$D=e.getUTCDate(),this.$W=e.getUTCDay(),this.$H=e.getUTCHours(),this.$m=e.getUTCMinutes(),this.$s=e.getUTCSeconds(),this.$ms=e.getUTCMilliseconds()}else f.call(this)};var t=p.utcOffset;p.utcOffset=function(e,o){var s=this.$utils().u;if(s(e))return this.$u?0:s(this.$offset)?t.call(this):this.$offset;if(typeof e=="string"&&(e=function(d){d===void 0&&(d="");var _=d.match(I);if(!_)return null;var v=(""+_[0]).match(k)||["-",0,0],u=v[0],h=60*+v[1]+ +v[2];return h===0?0:u==="+"?h:-h}(e),e===null))return this;var i=Math.abs(e)<=16?60*e:e,c=this;if(o)return c.$offset=i,c.$u=e===0,c;if(e!==0){var m=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(c=this.local().add(i+m,C)).$offset=i,c.$x.$localOffset=m}else c=this.utc();return c};var n=p.format;p.format=function(e){var o=e||(this.$u?"YYYY-MM-DDTHH:mm:ss[Z]":"");return n.call(this,o)},p.valueOf=function(){var e=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*e},p.isUTC=function(){return!!this.$u},p.toISOString=function(){return this.toDate().toISOString()},p.toString=function(){return this.toDate().toUTCString()};var a=p.toDate;p.toDate=function(e){return e==="s"&&this.$offset?l(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate():a.call(this)};var r=p.diff;p.diff=function(e,o,s){if(e&&this.$u===e.$u)return r.call(this,e,o,s);var i=this.local(),c=l(e).local();return r.call(i,c,o,s)}}})})(X);var me=X.exports;const he=G(me);var ee={exports:{}};(function(A,N){(function(C,I){A.exports=I()})(self,()=>{return C={7629:(k,$,b)=>{const l=b(375),p=b(8571),g=b(9474),f=b(1687),t=b(8652),n=b(8160),a=b(3292),r=b(6354),e=b(8901),o=b(9708),s=b(6914),i=b(2294),c=b(6133),m=b(1152),d=b(8863),_=b(2036),v={Base:class{constructor(u){this.type=u,this.$_root=null,this._definition={},this._reset()}_reset(){this._ids=new i.Ids,this._preferences=null,this._refs=new c.Manager,this._cache=null,this._valids=null,this._invalids=null,this._flags={},this._rules=[],this._singleRules=new Map,this.$_terms={},this.$_temp={ruleset:null,whens:{}}}describe(){return l(typeof o.describe=="function","Manifest functionality disabled"),o.describe(this)}allow(...u){return n.verifyFlat(u,"allow"),this._values(u,"_valids")}alter(u){l(u&&typeof u=="object"&&!Array.isArray(u),"Invalid targets argument"),l(!this._inRuleset(),"Cannot set alterations inside a ruleset");const h=this.clone();h.$_terms.alterations=h.$_terms.alterations||[];for(const y in u){const w=u[y];l(typeof w=="function","Alteration adjuster for",y,"must be a function"),h.$_terms.alterations.push({target:y,adjuster:w})}return h.$_temp.ruleset=!1,h}artifact(u){return l(u!==void 0,"Artifact cannot be undefined"),l(!this._cache,"Cannot set an artifact with a rule cache"),this.$_setFlag("artifact",u)}cast(u){return l(u===!1||typeof u=="string","Invalid to value"),l(u===!1||this._definition.cast[u],"Type",this.type,"does not support casting to",u),this.$_setFlag("cast",u===!1?void 0:u)}default(u,h){return this._default("default",u,h)}description(u){return l(u&&typeof u=="string","Description must be a non-empty string"),this.$_setFlag("description",u)}empty(u){const h=this.clone();return u!==void 0&&(u=h.$_compile(u,{override:!1})),h.$_setFlag("empty",u,{clone:!1})}error(u){return l(u,"Missing error"),l(u instanceof Error||typeof u=="function","Must provide a valid Error object or a function"),this.$_setFlag("error",u)}example(u,h={}){return l(u!==void 0,"Missing example"),n.assertOptions(h,["override"]),this._inner("examples",u,{single:!0,override:h.override})}external(u,h){return typeof u=="object"&&(l(!h,"Cannot combine options with description"),h=u.description,u=u.method),l(typeof u=="function","Method must be a function"),l(h===void 0||h&&typeof h=="string","Description must be a non-empty string"),this._inner("externals",{method:u,description:h},{single:!0})}failover(u,h){return this._default("failover",u,h)}forbidden(){return this.presence("forbidden")}id(u){return u?(l(typeof u=="string","id must be a non-empty string"),l(/^[^\.]+$/.test(u),"id cannot contain period character"),this.$_setFlag("id",u)):this.$_setFlag("id",void 0)}invalid(...u){return this._values(u,"_invalids")}label(u){return l(u&&typeof u=="string","Label name must be a non-empty string"),this.$_setFlag("label",u)}meta(u){return l(u!==void 0,"Meta cannot be undefined"),this._inner("metas",u,{single:!0})}note(...u){l(u.length,"Missing notes");for(const h of u)l(h&&typeof h=="string","Notes must be non-empty strings");return this._inner("notes",u)}only(u=!0){return l(typeof u=="boolean","Invalid mode:",u),this.$_setFlag("only",u)}optional(){return this.presence("optional")}prefs(u){l(u,"Missing preferences"),l(u.context===void 0,"Cannot override context"),l(u.externals===void 0,"Cannot override externals"),l(u.warnings===void 0,"Cannot override warnings"),l(u.debug===void 0,"Cannot override debug"),n.checkPreferences(u);const h=this.clone();return h._preferences=n.preferences(h._preferences,u),h}presence(u){return l(["optional","required","forbidden"].includes(u),"Unknown presence mode",u),this.$_setFlag("presence",u)}raw(u=!0){return this.$_setFlag("result",u?"raw":void 0)}result(u){return l(["raw","strip"].includes(u),"Unknown result mode",u),this.$_setFlag("result",u)}required(){return this.presence("required")}strict(u){const h=this.clone(),y=u!==void 0&&!u;return h._preferences=n.preferences(h._preferences,{convert:y}),h}strip(u=!0){return this.$_setFlag("result",u?"strip":void 0)}tag(...u){l(u.length,"Missing tags");for(const h of u)l(h&&typeof h=="string","Tags must be non-empty strings");return this._inner("tags",u)}unit(u){return l(u&&typeof u=="string","Unit name must be a non-empty string"),this.$_setFlag("unit",u)}valid(...u){n.verifyFlat(u,"valid");const h=this.allow(...u);return h.$_setFlag("only",!!h._valids,{clone:!1}),h}when(u,h){const y=this.clone();y.$_terms.whens||(y.$_terms.whens=[]);const w=a.when(y,u,h);if(!["any","link"].includes(y.type)){const x=w.is?[w]:w.switch;for(const j of x)l(!j.then||j.then.type==="any"||j.then.type===y.type,"Cannot combine",y.type,"with",j.then&&j.then.type),l(!j.otherwise||j.otherwise.type==="any"||j.otherwise.type===y.type,"Cannot combine",y.type,"with",j.otherwise&&j.otherwise.type)}return y.$_terms.whens.push(w),y.$_mutateRebuild()}cache(u){l(!this._inRuleset(),"Cannot set caching inside a ruleset"),l(!this._cache,"Cannot override schema cache"),l(this._flags.artifact===void 0,"Cannot cache a rule with an artifact");const h=this.clone();return h._cache=u||t.provider.provision(),h.$_temp.ruleset=!1,h}clone(){const u=Object.create(Object.getPrototypeOf(this));return this._assign(u)}concat(u){l(n.isSchema(u),"Invalid schema object"),l(this.type==="any"||u.type==="any"||u.type===this.type,"Cannot merge type",this.type,"with another type:",u.type),l(!this._inRuleset(),"Cannot concatenate onto a schema with open ruleset"),l(!u._inRuleset(),"Cannot concatenate a schema with open ruleset");let h=this.clone();if(this.type==="any"&&u.type!=="any"){const y=u.clone();for(const w of Object.keys(h))w!=="type"&&(y[w]=h[w]);h=y}h._ids.concat(u._ids),h._refs.register(u,c.toSibling),h._preferences=h._preferences?n.preferences(h._preferences,u._preferences):u._preferences,h._valids=_.merge(h._valids,u._valids,u._invalids),h._invalids=_.merge(h._invalids,u._invalids,u._valids);for(const y of u._singleRules.keys())h._singleRules.has(y)&&(h._rules=h._rules.filter(w=>w.keep||w.name!==y),h._singleRules.delete(y));for(const y of u._rules)u._definition.rules[y.method].multi||h._singleRules.set(y.name,y),h._rules.push(y);if(h._flags.empty&&u._flags.empty){h._flags.empty=h._flags.empty.concat(u._flags.empty);const y=Object.assign({},u._flags);delete y.empty,f(h._flags,y)}else if(u._flags.empty){h._flags.empty=u._flags.empty;const y=Object.assign({},u._flags);delete y.empty,f(h._flags,y)}else f(h._flags,u._flags);for(const y in u.$_terms){const w=u.$_terms[y];w?h.$_terms[y]?h.$_terms[y]=h.$_terms[y].concat(w):h.$_terms[y]=w.slice():h.$_terms[y]||(h.$_terms[y]=w)}return this.$_root._tracer&&this.$_root._tracer._combine(h,[this,u]),h.$_mutateRebuild()}extend(u){return l(!u.base,"Cannot extend type with another base"),e.type(this,u)}extract(u){return u=Array.isArray(u)?u:u.split("."),this._ids.reach(u)}fork(u,h){l(!this._inRuleset(),"Cannot fork inside a ruleset");let y=this;for(let w of[].concat(u))w=Array.isArray(w)?w:w.split("."),y=y._ids.fork(w,h,y);return y.$_temp.ruleset=!1,y}rule(u){const h=this._definition;n.assertOptions(u,Object.keys(h.modifiers)),l(this.$_temp.ruleset!==!1,"Cannot apply rules to empty ruleset or the last rule added does not support rule properties");const y=this.$_temp.ruleset===null?this._rules.length-1:this.$_temp.ruleset;l(y>=0&&y<this._rules.length,"Cannot apply rules to empty ruleset");const w=this.clone();for(let x=y;x<w._rules.length;++x){const j=w._rules[x],S=p(j);for(const R in u)h.modifiers[R](S,u[R]),l(S.name===j.name,"Cannot change rule name");w._rules[x]=S,w._singleRules.get(S.name)===j&&w._singleRules.set(S.name,S)}return w.$_temp.ruleset=!1,w.$_mutateRebuild()}get ruleset(){l(!this._inRuleset(),"Cannot start a new ruleset without closing the previous one");const u=this.clone();return u.$_temp.ruleset=u._rules.length,u}get $(){return this.ruleset}tailor(u){u=[].concat(u),l(!this._inRuleset(),"Cannot tailor inside a ruleset");let h=this;if(this.$_terms.alterations)for(const{target:y,adjuster:w}of this.$_terms.alterations)u.includes(y)&&(h=w(h),l(n.isSchema(h),"Alteration adjuster for",y,"failed to return a schema object"));return h=h.$_modify({each:y=>y.tailor(u),ref:!1}),h.$_temp.ruleset=!1,h.$_mutateRebuild()}tracer(){return m.location?m.location(this):this}validate(u,h){return d.entry(u,this,h)}validateAsync(u,h){return d.entryAsync(u,this,h)}$_addRule(u){typeof u=="string"&&(u={name:u}),l(u&&typeof u=="object","Invalid options"),l(u.name&&typeof u.name=="string","Invalid rule name");for(const j in u)l(j[0]!=="_","Cannot set private rule properties");const h=Object.assign({},u);h._resolve=[],h.method=h.method||h.name;const y=this._definition.rules[h.method],w=h.args;l(y,"Unknown rule",h.method);const x=this.clone();if(w){l(Object.keys(w).length===1||Object.keys(w).length===this._definition.rules[h.name].args.length,"Invalid rule definition for",this.type,h.name);for(const j in w){let S=w[j];if(y.argsByName){const R=y.argsByName.get(j);if(R.ref&&n.isResolvable(S))h._resolve.push(j),x.$_mutateRegister(S);else if(R.normalize&&(S=R.normalize(S),w[j]=S),R.assert){const O=n.validateArg(S,j,R);l(!O,O,"or reference")}}S!==void 0?w[j]=S:delete w[j]}}return y.multi||(x._ruleRemove(h.name,{clone:!1}),x._singleRules.set(h.name,h)),x.$_temp.ruleset===!1&&(x.$_temp.ruleset=null),y.priority?x._rules.unshift(h):x._rules.push(h),x}$_compile(u,h){return a.schema(this.$_root,u,h)}$_createError(u,h,y,w,x,j={}){const S=j.flags!==!1?this._flags:{},R=j.messages?s.merge(this._definition.messages,j.messages):this._definition.messages;return new r.Report(u,h,y,S,R,w,x)}$_getFlag(u){return this._flags[u]}$_getRule(u){return this._singleRules.get(u)}$_mapLabels(u){return u=Array.isArray(u)?u:u.split("."),this._ids.labels(u)}$_match(u,h,y,w){(y=Object.assign({},y)).abortEarly=!0,y._externals=!1,h.snapshot();const x=!d.validate(u,this,h,y,w).errors;return h.restore(),x}$_modify(u){return n.assertOptions(u,["each","once","ref","schema"]),i.schema(this,u)||this}$_mutateRebuild(){return l(!this._inRuleset(),"Cannot add this rule inside a ruleset"),this._refs.reset(),this._ids.reset(),this.$_modify({each:(u,{source:h,name:y,path:w,key:x})=>{const j=this._definition[h][y]&&this._definition[h][y].register;j!==!1&&this.$_mutateRegister(u,{family:j,key:x})}}),this._definition.rebuild&&this._definition.rebuild(this),this.$_temp.ruleset=!1,this}$_mutateRegister(u,{family:h,key:y}={}){this._refs.register(u,h),this._ids.register(u,{key:y})}$_property(u){return this._definition.properties[u]}$_reach(u){return this._ids.reach(u)}$_rootReferences(){return this._refs.roots()}$_setFlag(u,h,y={}){l(u[0]==="_"||!this._inRuleset(),"Cannot set flag inside a ruleset");const w=this._definition.flags[u]||{};if(g(h,w.default)&&(h=void 0),g(h,this._flags[u]))return this;const x=y.clone!==!1?this.clone():this;return h!==void 0?(x._flags[u]=h,x.$_mutateRegister(h)):delete x._flags[u],u[0]!=="_"&&(x.$_temp.ruleset=!1),x}$_parent(u,...h){return this[u][n.symbols.parent].call(this,...h)}$_validate(u,h,y){return d.validate(u,this,h,y)}_assign(u){u.type=this.type,u.$_root=this.$_root,u.$_temp=Object.assign({},this.$_temp),u.$_temp.whens={},u._ids=this._ids.clone(),u._preferences=this._preferences,u._valids=this._valids&&this._valids.clone(),u._invalids=this._invalids&&this._invalids.clone(),u._rules=this._rules.slice(),u._singleRules=p(this._singleRules,{shallow:!0}),u._refs=this._refs.clone(),u._flags=Object.assign({},this._flags),u._cache=null,u.$_terms={};for(const h in this.$_terms)u.$_terms[h]=this.$_terms[h]?this.$_terms[h].slice():null;u.$_super={};for(const h in this.$_super)u.$_super[h]=this._super[h].bind(u);return u}_bare(){const u=this.clone();u._reset();const h=u._definition.terms;for(const y in h){const w=h[y];u.$_terms[y]=w.init}return u.$_mutateRebuild()}_default(u,h,y={}){return n.assertOptions(y,"literal"),l(h!==void 0,"Missing",u,"value"),l(typeof h=="function"||!y.literal,"Only function value supports literal option"),typeof h=="function"&&y.literal&&(h={[n.symbols.literal]:!0,literal:h}),this.$_setFlag(u,h)}_generate(u,h,y){if(!this.$_terms.whens)return{schema:this};const w=[],x=[];for(let R=0;R<this.$_terms.whens.length;++R){const O=this.$_terms.whens[R];if(O.concat){w.push(O.concat),x.push(`${R}.concat`);continue}const D=O.ref?O.ref.resolve(u,h,y):u,L=O.is?[O]:O.switch,z=x.length;for(let M=0;M<L.length;++M){const{is:E,then:T,otherwise:P}=L[M],Y=`${R}${O.switch?"."+M:""}`;if(E.$_match(D,h.nest(E,`${Y}.is`),y)){if(T){const H=h.localize([...h.path,`${Y}.then`],h.ancestors,h.schemas),{schema:W,id:B}=T._generate(u,H,y);w.push(W),x.push(`${Y}.then${B?`(${B})`:""}`);break}}else if(P){const H=h.localize([...h.path,`${Y}.otherwise`],h.ancestors,h.schemas),{schema:W,id:B}=P._generate(u,H,y);w.push(W),x.push(`${Y}.otherwise${B?`(${B})`:""}`);break}}if(O.break&&x.length>z)break}const j=x.join(", ");if(h.mainstay.tracer.debug(h,"rule","when",j),!j)return{schema:this};if(!h.mainstay.tracer.active&&this.$_temp.whens[j])return{schema:this.$_temp.whens[j],id:j};let S=this;this._definition.generate&&(S=this._definition.generate(this,u,h,y));for(const R of w)S=S.concat(R);return this.$_root._tracer&&this.$_root._tracer._combine(S,[this,...w]),this.$_temp.whens[j]=S,{schema:S,id:j}}_inner(u,h,y={}){l(!this._inRuleset(),`Cannot set ${u} inside a ruleset`);const w=this.clone();return w.$_terms[u]&&!y.override||(w.$_terms[u]=[]),y.single?w.$_terms[u].push(h):w.$_terms[u].push(...h),w.$_temp.ruleset=!1,w}_inRuleset(){return this.$_temp.ruleset!==null&&this.$_temp.ruleset!==!1}_ruleRemove(u,h={}){if(!this._singleRules.has(u))return this;const y=h.clone!==!1?this.clone():this;y._singleRules.delete(u);const w=[];for(let x=0;x<y._rules.length;++x){const j=y._rules[x];j.name!==u||j.keep?w.push(j):y._inRuleset()&&x<y.$_temp.ruleset&&--y.$_temp.ruleset}return y._rules=w,y}_values(u,h){n.verifyFlat(u,h.slice(1,-1));const y=this.clone(),w=u[0]===n.symbols.override;if(w&&(u=u.slice(1)),!y[h]&&u.length?y[h]=new _:w&&(y[h]=u.length?new _:null,y.$_mutateRebuild()),!y[h])return y;w&&y[h].override();for(const x of u){l(x!==void 0,"Cannot call allow/valid/invalid with undefined"),l(x!==n.symbols.override,"Override must be the first value");const j=h==="_invalids"?"_valids":"_invalids";y[j]&&(y[j].remove(x),y[j].length||(l(h==="_valids"||!y._flags.only,"Setting invalid value",x,"leaves schema rejecting all values due to previous valid rule"),y[j]=null)),y[h].add(x,y._refs)}return y}}};v.Base.prototype[n.symbols.any]={version:n.version,compile:a.compile,root:"$_root"},v.Base.prototype.isImmutable=!0,v.Base.prototype.deny=v.Base.prototype.invalid,v.Base.prototype.disallow=v.Base.prototype.invalid,v.Base.prototype.equal=v.Base.prototype.valid,v.Base.prototype.exist=v.Base.prototype.required,v.Base.prototype.not=v.Base.prototype.invalid,v.Base.prototype.options=v.Base.prototype.prefs,v.Base.prototype.preferences=v.Base.prototype.prefs,k.exports=new v.Base},8652:(k,$,b)=>{const l=b(375),p=b(8571),g=b(8160),f={max:1e3,supported:new Set(["undefined","boolean","number","string"])};$.provider={provision:t=>new f.Cache(t)},f.Cache=class{constructor(t={}){g.assertOptions(t,["max"]),l(t.max===void 0||t.max&&t.max>0&&isFinite(t.max),"Invalid max cache size"),this._max=t.max||f.max,this._map=new Map,this._list=new f.List}get length(){return this._map.size}set(t,n){if(t!==null&&!f.supported.has(typeof t))return;let a=this._map.get(t);if(a)return a.value=n,void this._list.first(a);a=this._list.unshift({key:t,value:n}),this._map.set(t,a),this._compact()}get(t){const n=this._map.get(t);if(n)return this._list.first(n),p(n.value)}_compact(){if(this._map.size>this._max){const t=this._list.pop();this._map.delete(t.key)}}},f.List=class{constructor(){this.tail=null,this.head=null}unshift(t){return t.next=null,t.prev=this.head,this.head&&(this.head.next=t),this.head=t,this.tail||(this.tail=t),t}first(t){t!==this.head&&(this._remove(t),this.unshift(t))}pop(){return this._remove(this.tail)}_remove(t){const{next:n,prev:a}=t;return n.prev=a,a&&(a.next=n),t===this.tail&&(this.tail=n),t.prev=null,t.next=null,t}}},8160:(k,$,b)=>{const l=b(375),p=b(7916),g=b(5934);let f,t;const n={isoDate:/^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/};$.version=g.version,$.defaults={abortEarly:!0,allowUnknown:!1,artifacts:!1,cache:!0,context:null,convert:!0,dateFormat:"iso",errors:{escapeHtml:!1,label:"path",language:null,render:!0,stack:!1,wrap:{label:'"',array:"[]"}},externals:!0,messages:{},nonEnumerables:!1,noDefaults:!1,presence:"optional",skipFunctions:!1,stripUnknown:!1,warnings:!1},$.symbols={any:Symbol.for("@hapi/joi/schema"),arraySingle:Symbol("arraySingle"),deepDefault:Symbol("deepDefault"),errors:Symbol("errors"),literal:Symbol("literal"),override:Symbol("override"),parent:Symbol("parent"),prefs:Symbol("prefs"),ref:Symbol("ref"),template:Symbol("template"),values:Symbol("values")},$.assertOptions=function(a,r,e="Options"){l(a&&typeof a=="object"&&!Array.isArray(a),"Options must be of type object");const o=Object.keys(a).filter(s=>!r.includes(s));l(o.length===0,`${e} contain unknown keys: ${o}`)},$.checkPreferences=function(a){t=t||b(3378);const r=t.preferences.validate(a);if(r.error)throw new p([r.error.details[0].message])},$.compare=function(a,r,e){switch(e){case"=":return a===r;case">":return a>r;case"<":return a<r;case">=":return a>=r;case"<=":return a<=r}},$.default=function(a,r){return a===void 0?r:a},$.isIsoDate=function(a){return n.isoDate.test(a)},$.isNumber=function(a){return typeof a=="number"&&!isNaN(a)},$.isResolvable=function(a){return!!a&&(a[$.symbols.ref]||a[$.symbols.template])},$.isSchema=function(a,r={}){const e=a&&a[$.symbols.any];return!!e&&(l(r.legacy||e.version===$.version,"Cannot mix different versions of joi schemas"),!0)},$.isValues=function(a){return a[$.symbols.values]},$.limit=function(a){return Number.isSafeInteger(a)&&a>=0},$.preferences=function(a,r){f=f||b(6914),a=a||{},r=r||{};const e=Object.assign({},a,r);return r.errors&&a.errors&&(e.errors=Object.assign({},a.errors,r.errors),e.errors.wrap=Object.assign({},a.errors.wrap,r.errors.wrap)),r.messages&&(e.messages=f.compile(r.messages,a.messages)),delete e[$.symbols.prefs],e},$.tryWithPath=function(a,r,e={}){try{return a()}catch(o){throw o.path!==void 0?o.path=r+"."+o.path:o.path=r,e.append&&(o.message=`${o.message} (${o.path})`),o}},$.validateArg=function(a,r,{assert:e,message:o}){if($.isSchema(e)){const s=e.validate(a);return s.error?s.error.message:void 0}if(!e(a))return r?`${r} ${o}`:o},$.verifyFlat=function(a,r){for(const e of a)l(!Array.isArray(e),"Method no longer accepts array arguments:",r)}},3292:(k,$,b)=>{const l=b(375),p=b(8160),g=b(6133),f={};$.schema=function(t,n,a={}){p.assertOptions(a,["appendPath","override"]);try{return f.schema(t,n,a)}catch(r){throw a.appendPath&&r.path!==void 0&&(r.message=`${r.message} (${r.path})`),r}},f.schema=function(t,n,a){l(n!==void 0,"Invalid undefined schema"),Array.isArray(n)&&(l(n.length,"Invalid empty array schema"),n.length===1&&(n=n[0]));const r=(e,...o)=>a.override!==!1?e.valid(t.override,...o):e.valid(...o);if(f.simple(n))return r(t,n);if(typeof n=="function")return t.custom(n);if(l(typeof n=="object","Invalid schema content:",typeof n),p.isResolvable(n))return r(t,n);if(p.isSchema(n))return n;if(Array.isArray(n)){for(const e of n)if(!f.simple(e))return t.alternatives().try(...n);return r(t,...n)}return n instanceof RegExp?t.string().regex(n):n instanceof Date?r(t.date(),n):(l(Object.getPrototypeOf(n)===Object.getPrototypeOf({}),"Schema can only contain plain objects"),t.object().keys(n))},$.ref=function(t,n){return g.isRef(t)?t:g.create(t,n)},$.compile=function(t,n,a={}){p.assertOptions(a,["legacy"]);const r=n&&n[p.symbols.any];if(r)return l(a.legacy||r.version===p.version,"Cannot mix different versions of joi schemas:",r.version,p.version),n;if(typeof n!="object"||!a.legacy)return $.schema(t,n,{appendPath:!0});const e=f.walk(n);return e?e.compile(e.root,n):$.schema(t,n,{appendPath:!0})},f.walk=function(t){if(typeof t!="object")return null;if(Array.isArray(t)){for(const a of t){const r=f.walk(a);if(r)return r}return null}const n=t[p.symbols.any];if(n)return{root:t[n.root],compile:n.compile};l(Object.getPrototypeOf(t)===Object.getPrototypeOf({}),"Schema can only contain plain objects");for(const a in t){const r=f.walk(t[a]);if(r)return r}return null},f.simple=function(t){return t===null||["boolean","string","number"].includes(typeof t)},$.when=function(t,n,a){if(a===void 0&&(l(n&&typeof n=="object","Missing options"),a=n,n=g.create(".")),Array.isArray(a)&&(a={switch:a}),p.assertOptions(a,["is","not","then","otherwise","switch","break"]),p.isSchema(n))return l(a.is===void 0,'"is" can not be used with a schema condition'),l(a.not===void 0,'"not" can not be used with a schema condition'),l(a.switch===void 0,'"switch" can not be used with a schema condition'),f.condition(t,{is:n,then:a.then,otherwise:a.otherwise,break:a.break});if(l(g.isRef(n)||typeof n=="string","Invalid condition:",n),l(a.not===void 0||a.is===void 0,'Cannot combine "is" with "not"'),a.switch===void 0){let e=a;a.not!==void 0&&(e={is:a.not,then:a.otherwise,otherwise:a.then,break:a.break});let o=e.is!==void 0?t.$_compile(e.is):t.$_root.invalid(null,!1,0,"").required();return l(e.then!==void 0||e.otherwise!==void 0,'options must have at least one of "then", "otherwise", or "switch"'),l(e.break===void 0||e.then===void 0||e.otherwise===void 0,"Cannot specify then, otherwise, and break all together"),a.is===void 0||g.isRef(a.is)||p.isSchema(a.is)||(o=o.required()),f.condition(t,{ref:$.ref(n),is:o,then:e.then,otherwise:e.otherwise,break:e.break})}l(Array.isArray(a.switch),'"switch" must be an array'),l(a.is===void 0,'Cannot combine "switch" with "is"'),l(a.not===void 0,'Cannot combine "switch" with "not"'),l(a.then===void 0,'Cannot combine "switch" with "then"');const r={ref:$.ref(n),switch:[],break:a.break};for(let e=0;e<a.switch.length;++e){const o=a.switch[e],s=e===a.switch.length-1;p.assertOptions(o,s?["is","then","otherwise"]:["is","then"]),l(o.is!==void 0,'Switch statement missing "is"'),l(o.then!==void 0,'Switch statement missing "then"');const i={is:t.$_compile(o.is),then:t.$_compile(o.then)};if(g.isRef(o.is)||p.isSchema(o.is)||(i.is=i.is.required()),s){l(a.otherwise===void 0||o.otherwise===void 0,'Cannot specify "otherwise" inside and outside a "switch"');const c=a.otherwise!==void 0?a.otherwise:o.otherwise;c!==void 0&&(l(r.break===void 0,"Cannot specify both otherwise and break"),i.otherwise=t.$_compile(c))}r.switch.push(i)}return r},f.condition=function(t,n){for(const a of["then","otherwise"])n[a]===void 0?delete n[a]:n[a]=t.$_compile(n[a]);return n}},6354:(k,$,b)=>{const l=b(5688),p=b(8160),g=b(3328);$.Report=class{constructor(f,t,n,a,r,e,o){if(this.code=f,this.flags=a,this.messages=r,this.path=e.path,this.prefs=o,this.state=e,this.value=t,this.message=null,this.template=null,this.local=n||{},this.local.label=$.label(this.flags,this.state,this.prefs,this.messages),this.value===void 0||this.local.hasOwnProperty("value")||(this.local.value=this.value),this.path.length){const s=this.path[this.path.length-1];typeof s!="object"&&(this.local.key=s)}}_setTemplate(f){if(this.template=f,!this.flags.label&&this.path.length===0){const t=this._template(this.template,"root");t&&(this.local.label=t)}}toString(){if(this.message)return this.message;const f=this.code;if(!this.prefs.errors.render)return this.code;const t=this._template(this.template)||this._template(this.prefs.messages)||this._template(this.messages);return t===void 0?`Error code "${f}" is not defined, your custom type is missing the correct messages definition`:(this.message=t.render(this.value,this.state,this.prefs,this.local,{errors:this.prefs.errors,messages:[this.prefs.messages,this.messages]}),this.prefs.errors.label||(this.message=this.message.replace(/^"" /,"").trim()),this.message)}_template(f,t){return $.template(this.value,f,t||this.code,this.state,this.prefs)}},$.path=function(f){let t="";for(const n of f)typeof n!="object"&&(typeof n=="string"?(t&&(t+="."),t+=n):t+=`[${n}]`);return t},$.template=function(f,t,n,a,r){if(!t)return;if(g.isTemplate(t))return n!=="root"?t:null;let e=r.errors.language;if(p.isResolvable(e)&&(e=e.resolve(f,a,r)),e&&t[e]){if(t[e][n]!==void 0)return t[e][n];if(t[e]["*"]!==void 0)return t[e]["*"]}return t[n]?t[n]:t["*"]},$.label=function(f,t,n,a){if(f.label)return f.label;if(!n.errors.label)return"";let r=t.path;return n.errors.label==="key"&&t.path.length>1&&(r=t.path.slice(-1)),$.path(r)||$.template(null,n.messages,"root",t,n)||a&&$.template(null,a,"root",t,n)||"value"},$.process=function(f,t,n){if(!f)return null;const{override:a,message:r,details:e}=$.details(f);if(a)return a;if(n.errors.stack)return new $.ValidationError(r,e,t);const o=Error.stackTraceLimit;Error.stackTraceLimit=0;const s=new $.ValidationError(r,e,t);return Error.stackTraceLimit=o,s},$.details=function(f,t={}){let n=[];const a=[];for(const r of f){if(r instanceof Error){if(t.override!==!1)return{override:r};const o=r.toString();n.push(o),a.push({message:o,type:"override",context:{error:r}});continue}const e=r.toString();n.push(e),a.push({message:e,path:r.path.filter(o=>typeof o!="object"),type:r.code,context:r.local})}return n.length>1&&(n=[...new Set(n)]),{message:n.join(". "),details:a}},$.ValidationError=class extends Error{constructor(f,t,n){super(f),this._original=n,this.details=t}static isError(f){return f instanceof $.ValidationError}},$.ValidationError.prototype.isJoi=!0,$.ValidationError.prototype.name="ValidationError",$.ValidationError.prototype.annotate=l.error},8901:(k,$,b)=>{const l=b(375),p=b(8571),g=b(8160),f=b(6914),t={};$.type=function(n,a){const r=Object.getPrototypeOf(n),e=p(r),o=n._assign(Object.create(e)),s=Object.assign({},a);delete s.base,e._definition=s;const i=r._definition||{};s.messages=f.merge(i.messages,s.messages),s.properties=Object.assign({},i.properties,s.properties),o.type=s.type,s.flags=Object.assign({},i.flags,s.flags);const c=Object.assign({},i.terms);if(s.terms)for(const v in s.terms){const u=s.terms[v];l(o.$_terms[v]===void 0,"Invalid term override for",s.type,v),o.$_terms[v]=u.init,c[v]=u}s.terms=c,s.args||(s.args=i.args),s.prepare=t.prepare(s.prepare,i.prepare),s.coerce&&(typeof s.coerce=="function"&&(s.coerce={method:s.coerce}),s.coerce.from&&!Array.isArray(s.coerce.from)&&(s.coerce={method:s.coerce.method,from:[].concat(s.coerce.from)})),s.coerce=t.coerce(s.coerce,i.coerce),s.validate=t.validate(s.validate,i.validate);const m=Object.assign({},i.rules);if(s.rules)for(const v in s.rules){const u=s.rules[v];l(typeof u=="object","Invalid rule definition for",s.type,v);let h=u.method;if(h===void 0&&(h=function(){return this.$_addRule(v)}),h&&(l(!e[v],"Rule conflict in",s.type,v),e[v]=h),l(!m[v],"Rule conflict in",s.type,v),m[v]=u,u.alias){const y=[].concat(u.alias);for(const w of y)e[w]=u.method}u.args&&(u.argsByName=new Map,u.args=u.args.map(y=>(typeof y=="string"&&(y={name:y}),l(!u.argsByName.has(y.name),"Duplicated argument name",y.name),g.isSchema(y.assert)&&(y.assert=y.assert.strict().label(y.name)),u.argsByName.set(y.name,y),y)))}s.rules=m;const d=Object.assign({},i.modifiers);if(s.modifiers)for(const v in s.modifiers){l(!e[v],"Rule conflict in",s.type,v);const u=s.modifiers[v];l(typeof u=="function","Invalid modifier definition for",s.type,v);const h=function(y){return this.rule({[v]:y})};e[v]=h,d[v]=u}if(s.modifiers=d,s.overrides){e._super=r,o.$_super={};for(const v in s.overrides)l(r[v],"Cannot override missing",v),s.overrides[v][g.symbols.parent]=r[v],o.$_super[v]=r[v].bind(o);Object.assign(e,s.overrides)}s.cast=Object.assign({},i.cast,s.cast);const _=Object.assign({},i.manifest,s.manifest);return _.build=t.build(s.manifest&&s.manifest.build,i.manifest&&i.manifest.build),s.manifest=_,s.rebuild=t.rebuild(s.rebuild,i.rebuild),o},t.build=function(n,a){return n&&a?function(r,e){return a(n(r,e),e)}:n||a},t.coerce=function(n,a){return n&&a?{from:n.from&&a.from?[...new Set([...n.from,...a.from])]:null,method(r,e){let o;if((!a.from||a.from.includes(typeof r))&&(o=a.method(r,e),o)){if(o.errors||o.value===void 0)return o;r=o.value}if(!n.from||n.from.includes(typeof r)){const s=n.method(r,e);if(s)return s}return o}}:n||a},t.prepare=function(n,a){return n&&a?function(r,e){const o=n(r,e);if(o){if(o.errors||o.value===void 0)return o;r=o.value}return a(r,e)||o}:n||a},t.rebuild=function(n,a){return n&&a?function(r){a(r),n(r)}:n||a},t.validate=function(n,a){return n&&a?function(r,e){const o=a(r,e);if(o){if(o.errors&&(!Array.isArray(o.errors)||o.errors.length))return o;r=o.value}return n(r,e)||o}:n||a}},5107:(k,$,b)=>{const l=b(375),p=b(8571),g=b(8652),f=b(8160),t=b(3292),n=b(6354),a=b(8901),r=b(9708),e=b(6133),o=b(3328),s=b(1152);let i;const c={types:{alternatives:b(4946),any:b(8068),array:b(546),boolean:b(4937),date:b(7500),function:b(390),link:b(8785),number:b(3832),object:b(8966),string:b(7417),symbol:b(8826)},aliases:{alt:"alternatives",bool:"boolean",func:"function"},root:function(){const m={_types:new Set(Object.keys(c.types))};for(const d of m._types)m[d]=function(..._){return l(!_.length||["alternatives","link","object"].includes(d),"The",d,"type does not allow arguments"),c.generate(this,c.types[d],_)};for(const d of["allow","custom","disallow","equal","exist","forbidden","invalid","not","only","optional","options","prefs","preferences","required","strip","valid","when"])m[d]=function(..._){return this.any()[d](..._)};Object.assign(m,c.methods);for(const d in c.aliases){const _=c.aliases[d];m[d]=m[_]}return m.x=m.expression,s.setup&&s.setup(m),m}};c.methods={ValidationError:n.ValidationError,version:f.version,cache:g.provider,assert(m,d,..._){c.assert(m,d,!0,_)},attempt:(m,d,..._)=>c.assert(m,d,!1,_),build(m){return l(typeof r.build=="function","Manifest functionality disabled"),r.build(this,m)},checkPreferences(m){f.checkPreferences(m)},compile(m,d){return t.compile(this,m,d)},defaults(m){l(typeof m=="function","modifier must be a function");const d=Object.assign({},this);for(const _ of d._types){const v=m(d[_]());l(f.isSchema(v),"modifier must return a valid schema object"),d[_]=function(...u){return c.generate(this,v,u)}}return d},expression:(...m)=>new o(...m),extend(...m){f.verifyFlat(m,"extend"),i=i||b(3378),l(m.length,"You need to provide at least one extension"),this.assert(m,i.extensions);const d=Object.assign({},this);d._types=new Set(d._types);for(let _ of m){typeof _=="function"&&(_=_(d)),this.assert(_,i.extension);const v=c.expandExtension(_,d);for(const u of v){l(d[u.type]===void 0||d._types.has(u.type),"Cannot override name",u.type);const h=u.base||this.any(),y=a.type(h,u);d._types.add(u.type),d[u.type]=function(...w){return c.generate(this,y,w)}}}return d},isError:n.ValidationError.isError,isExpression:o.isTemplate,isRef:e.isRef,isSchema:f.isSchema,in:(...m)=>e.in(...m),override:f.symbols.override,ref:(...m)=>e.create(...m),types(){const m={};for(const d of this._types)m[d]=this[d]();for(const d in c.aliases)m[d]=this[d]();return m}},c.assert=function(m,d,_,v){const u=v[0]instanceof Error||typeof v[0]=="string"?v[0]:null,h=u!==null?v[1]:v[0],y=d.validate(m,f.preferences({errors:{stack:!0}},h||{}));let w=y.error;if(!w)return y.value;if(u instanceof Error)throw u;const x=_&&typeof w.annotate=="function"?w.annotate():w.message;throw w instanceof n.ValidationError==0&&(w=p(w)),w.message=u?`${u} ${x}`:x,w},c.generate=function(m,d,_){return l(m,"Must be invoked on a Joi instance."),d.$_root=m,d._definition.args&&_.length?d._definition.args(d,..._):d},c.expandExtension=function(m,d){if(typeof m.type=="string")return[m];const _=[];for(const v of d._types)if(m.type.test(v)){const u=Object.assign({},m);u.type=v,u.base=d[v](),_.push(u)}return _},k.exports=c.root()},6914:(k,$,b)=>{const l=b(375),p=b(8571),g=b(3328);$.compile=function(f,t){if(typeof f=="string")return l(!t,"Cannot set single message string"),new g(f);if(g.isTemplate(f))return l(!t,"Cannot set single message template"),f;l(typeof f=="object"&&!Array.isArray(f),"Invalid message options"),t=t?p(t):{};for(let n in f){const a=f[n];if(n==="root"||g.isTemplate(a)){t[n]=a;continue}if(typeof a=="string"){t[n]=new g(a);continue}l(typeof a=="object"&&!Array.isArray(a),"Invalid message for",n);const r=n;for(n in t[r]=t[r]||{},a){const e=a[n];n==="root"||g.isTemplate(e)?t[r][n]=e:(l(typeof e=="string","Invalid message for",n,"in",r),t[r][n]=new g(e))}}return t},$.decompile=function(f){const t={};for(let n in f){const a=f[n];if(n==="root"){t.root=a;continue}if(g.isTemplate(a)){t[n]=a.describe({compact:!0});continue}const r=n;for(n in t[r]={},a){const e=a[n];n!=="root"?t[r][n]=e.describe({compact:!0}):t[r].root=e}}return t},$.merge=function(f,t){if(!f)return $.compile(t);if(!t)return f;if(typeof t=="string")return new g(t);if(g.isTemplate(t))return t;const n=p(f);for(let a in t){const r=t[a];if(a==="root"||g.isTemplate(r)){n[a]=r;continue}if(typeof r=="string"){n[a]=new g(r);continue}l(typeof r=="object"&&!Array.isArray(r),"Invalid message for",a);const e=a;for(a in n[e]=n[e]||{},r){const o=r[a];a==="root"||g.isTemplate(o)?n[e][a]=o:(l(typeof o=="string","Invalid message for",a,"in",e),n[e][a]=new g(o))}}return n}},2294:(k,$,b)=>{const l=b(375),p=b(8160),g=b(6133),f={};$.Ids=f.Ids=class{constructor(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}clone(){const t=new f.Ids;return t._byId=new Map(this._byId),t._byKey=new Map(this._byKey),t._schemaChain=this._schemaChain,t}concat(t){t._schemaChain&&(this._schemaChain=!0);for(const[n,a]of t._byId.entries())l(!this._byKey.has(n),"Schema id conflicts with existing key:",n),this._byId.set(n,a);for(const[n,a]of t._byKey.entries())l(!this._byId.has(n),"Schema key conflicts with existing id:",n),this._byKey.set(n,a)}fork(t,n,a){const r=this._collect(t);r.push({schema:a});const e=r.shift();let o={id:e.id,schema:n(e.schema)};l(p.isSchema(o.schema),"adjuster function failed to return a joi schema type");for(const s of r)o={id:s.id,schema:f.fork(s.schema,o.id,o.schema)};return o.schema}labels(t,n=[]){const a=t[0],r=this._get(a);if(!r)return[...n,...t].join(".");const e=t.slice(1);return n=[...n,r.schema._flags.label||a],e.length?r.schema._ids.labels(e,n):n.join(".")}reach(t,n=[]){const a=t[0],r=this._get(a);l(r,"Schema does not contain path",[...n,...t].join("."));const e=t.slice(1);return e.length?r.schema._ids.reach(e,[...n,a]):r.schema}register(t,{key:n}={}){if(!t||!p.isSchema(t))return;(t.$_property("schemaChain")||t._ids._schemaChain)&&(this._schemaChain=!0);const a=t._flags.id;if(a){const r=this._byId.get(a);l(!r||r.schema===t,"Cannot add different schemas with the same id:",a),l(!this._byKey.has(a),"Schema id conflicts with existing key:",a),this._byId.set(a,{schema:t,id:a})}n&&(l(!this._byKey.has(n),"Schema already contains key:",n),l(!this._byId.has(n),"Schema key conflicts with existing id:",n),this._byKey.set(n,{schema:t,id:n}))}reset(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}_collect(t,n=[],a=[]){const r=t[0],e=this._get(r);l(e,"Schema does not contain path",[...n,...t].join(".")),a=[e,...a];const o=t.slice(1);return o.length?e.schema._ids._collect(o,[...n,r],a):a}_get(t){return this._byId.get(t)||this._byKey.get(t)}},f.fork=function(t,n,a){const r=$.schema(t,{each:(e,{key:o})=>{if(n===(e._flags.id||o))return a},ref:!1});return r?r.$_mutateRebuild():t},$.schema=function(t,n){let a;for(const r in t._flags){if(r[0]==="_")continue;const e=f.scan(t._flags[r],{source:"flags",name:r},n);e!==void 0&&(a=a||t.clone(),a._flags[r]=e)}for(let r=0;r<t._rules.length;++r){const e=t._rules[r],o=f.scan(e.args,{source:"rules",name:e.name},n);if(o!==void 0){a=a||t.clone();const s=Object.assign({},e);s.args=o,a._rules[r]=s,a._singleRules.get(e.name)===e&&a._singleRules.set(e.name,s)}}for(const r in t.$_terms){if(r[0]==="_")continue;const e=f.scan(t.$_terms[r],{source:"terms",name:r},n);e!==void 0&&(a=a||t.clone(),a.$_terms[r]=e)}return a},f.scan=function(t,n,a,r,e){const o=r||[];if(t===null||typeof t!="object")return;let s;if(Array.isArray(t)){for(let i=0;i<t.length;++i){const c=n.source==="terms"&&n.name==="keys"&&t[i].key,m=f.scan(t[i],n,a,[i,...o],c);m!==void 0&&(s=s||t.slice(),s[i]=m)}return s}if(a.schema!==!1&&p.isSchema(t)||a.ref!==!1&&g.isRef(t)){const i=a.each(t,{...n,path:o,key:e});return i===t?void 0:i}for(const i in t){if(i[0]==="_")continue;const c=f.scan(t[i],n,a,[i,...o],e);c!==void 0&&(s=s||Object.assign({},t),s[i]=c)}return s}},6133:(k,$,b)=>{const l=b(375),p=b(8571),g=b(9621),f=b(8160);let t;const n={symbol:Symbol("ref"),defaults:{adjust:null,in:!1,iterables:null,map:null,separator:".",type:"value"}};$.create=function(a,r={}){l(typeof a=="string","Invalid reference key:",a),f.assertOptions(r,["adjust","ancestor","in","iterables","map","prefix","render","separator"]),l(!r.prefix||typeof r.prefix=="object","options.prefix must be of type object");const e=Object.assign({},n.defaults,r);delete e.prefix;const o=e.separator,s=n.context(a,o,r.prefix);if(e.type=s.type,a=s.key,e.type==="value")if(s.root&&(l(!o||a[0]!==o,"Cannot specify relative path with root prefix"),e.ancestor="root",a||(a=null)),o&&o===a)a=null,e.ancestor=0;else if(e.ancestor!==void 0)l(!o||!a||a[0]!==o,"Cannot combine prefix with ancestor option");else{const[i,c]=n.ancestor(a,o);c&&(a=a.slice(c))===""&&(a=null),e.ancestor=i}return e.path=o?a===null?[]:a.split(o):[a],new n.Ref(e)},$.in=function(a,r={}){return $.create(a,{...r,in:!0})},$.isRef=function(a){return!!a&&!!a[f.symbols.ref]},n.Ref=class{constructor(a){l(typeof a=="object","Invalid reference construction"),f.assertOptions(a,["adjust","ancestor","in","iterables","map","path","render","separator","type","depth","key","root","display"]),l([!1,void 0].includes(a.separator)||typeof a.separator=="string"&&a.separator.length===1,"Invalid separator"),l(!a.adjust||typeof a.adjust=="function","options.adjust must be a function"),l(!a.map||Array.isArray(a.map),"options.map must be an array"),l(!a.map||!a.adjust,"Cannot set both map and adjust options"),Object.assign(this,n.defaults,a),l(this.type==="value"||this.ancestor===void 0,"Non-value references cannot reference ancestors"),Array.isArray(this.map)&&(this.map=new Map(this.map)),this.depth=this.path.length,this.key=this.path.length?this.path.join(this.separator):null,this.root=this.path[0],this.updateDisplay()}resolve(a,r,e,o,s={}){return l(!this.in||s.in,"Invalid in() reference usage"),this.type==="global"?this._resolve(e.context,r,s):this.type==="local"?this._resolve(o,r,s):this.ancestor?this.ancestor==="root"?this._resolve(r.ancestors[r.ancestors.length-1],r,s):(l(this.ancestor<=r.ancestors.length,"Invalid reference exceeds the schema root:",this.display),this._resolve(r.ancestors[this.ancestor-1],r,s)):this._resolve(a,r,s)}_resolve(a,r,e){let o;if(this.type==="value"&&r.mainstay.shadow&&e.shadow!==!1&&(o=r.mainstay.shadow.get(this.absolute(r))),o===void 0&&(o=g(a,this.path,{iterables:this.iterables,functions:!0})),this.adjust&&(o=this.adjust(o)),this.map){const s=this.map.get(o);s!==void 0&&(o=s)}return r.mainstay&&r.mainstay.tracer.resolve(r,this,o),o}toString(){return this.display}absolute(a){return[...a.path.slice(0,-this.ancestor),...this.path]}clone(){return new n.Ref(this)}describe(){const a={path:this.path};this.type!=="value"&&(a.type=this.type),this.separator!=="."&&(a.separator=this.separator),this.type==="value"&&this.ancestor!==1&&(a.ancestor=this.ancestor),this.map&&(a.map=[...this.map]);for(const r of["adjust","iterables","render"])this[r]!==null&&this[r]!==void 0&&(a[r]=this[r]);return this.in!==!1&&(a.in=!0),{ref:a}}updateDisplay(){const a=this.key!==null?this.key:"";if(this.type!=="value")return void(this.display=`ref:${this.type}:${a}`);if(!this.separator)return void(this.display=`ref:${a}`);if(!this.ancestor)return void(this.display=`ref:${this.separator}${a}`);if(this.ancestor==="root")return void(this.display=`ref:root:${a}`);if(this.ancestor===1)return void(this.display=`ref:${a||".."}`);const r=new Array(this.ancestor+1).fill(this.separator).join("");this.display=`ref:${r}${a||""}`}},n.Ref.prototype[f.symbols.ref]=!0,$.build=function(a){return(a=Object.assign({},n.defaults,a)).type==="value"&&a.ancestor===void 0&&(a.ancestor=1),new n.Ref(a)},n.context=function(a,r,e={}){if(a=a.trim(),e){const o=e.global===void 0?"$":e.global;if(o!==r&&a.startsWith(o))return{key:a.slice(o.length),type:"global"};const s=e.local===void 0?"#":e.local;if(s!==r&&a.startsWith(s))return{key:a.slice(s.length),type:"local"};const i=e.root===void 0?"/":e.root;if(i!==r&&a.startsWith(i))return{key:a.slice(i.length),type:"value",root:!0}}return{key:a,type:"value"}},n.ancestor=function(a,r){if(!r)return[1,0];if(a[0]!==r)return[1,0];if(a[1]!==r)return[0,1];let e=2;for(;a[e]===r;)++e;return[e-1,e]},$.toSibling=0,$.toParent=1,$.Manager=class{constructor(){this.refs=[]}register(a,r){if(a)if(r=r===void 0?$.toParent:r,Array.isArray(a))for(const e of a)this.register(e,r);else if(f.isSchema(a))for(const e of a._refs.refs)e.ancestor-r>=0&&this.refs.push({ancestor:e.ancestor-r,root:e.root});else $.isRef(a)&&a.type==="value"&&a.ancestor-r>=0&&this.refs.push({ancestor:a.ancestor-r,root:a.root}),t=t||b(3328),t.isTemplate(a)&&this.register(a.refs(),r)}get length(){return this.refs.length}clone(){const a=new $.Manager;return a.refs=p(this.refs),a}reset(){this.refs=[]}roots(){return this.refs.filter(a=>!a.ancestor).map(a=>a.root)}}},3378:(k,$,b)=>{const l=b(5107),p={};p.wrap=l.string().min(1).max(2).allow(!1),$.preferences=l.object({allowUnknown:l.boolean(),abortEarly:l.boolean(),artifacts:l.boolean(),cache:l.boolean(),context:l.object(),convert:l.boolean(),dateFormat:l.valid("date","iso","string","time","utc"),debug:l.boolean(),errors:{escapeHtml:l.boolean(),label:l.valid("path","key",!1),language:[l.string(),l.object().ref()],render:l.boolean(),stack:l.boolean(),wrap:{label:p.wrap,array:p.wrap,string:p.wrap}},externals:l.boolean(),messages:l.object(),noDefaults:l.boolean(),nonEnumerables:l.boolean(),presence:l.valid("required","optional","forbidden"),skipFunctions:l.boolean(),stripUnknown:l.object({arrays:l.boolean(),objects:l.boolean()}).or("arrays","objects").allow(!0,!1),warnings:l.boolean()}).strict(),p.nameRx=/^[a-zA-Z0-9]\w*$/,p.rule=l.object({alias:l.array().items(l.string().pattern(p.nameRx)).single(),args:l.array().items(l.string(),l.object({name:l.string().pattern(p.nameRx).required(),ref:l.boolean(),assert:l.alternatives([l.function(),l.object().schema()]).conditional("ref",{is:!0,then:l.required()}),normalize:l.function(),message:l.string().when("assert",{is:l.function(),then:l.required()})})),convert:l.boolean(),manifest:l.boolean(),method:l.function().allow(!1),multi:l.boolean(),validate:l.function()}),$.extension=l.object({type:l.alternatives([l.string(),l.object().regex()]).required(),args:l.function(),cast:l.object().pattern(p.nameRx,l.object({from:l.function().maxArity(1).required(),to:l.function().minArity(1).maxArity(2).required()})),base:l.object().schema().when("type",{is:l.object().regex(),then:l.forbidden()}),coerce:[l.function().maxArity(3),l.object({method:l.function().maxArity(3).required(),from:l.array().items(l.string()).single()})],flags:l.object().pattern(p.nameRx,l.object({setter:l.string(),default:l.any()})),manifest:{build:l.function().arity(2)},messages:[l.object(),l.string()],modifiers:l.object().pattern(p.nameRx,l.function().minArity(1).maxArity(2)),overrides:l.object().pattern(p.nameRx,l.function()),prepare:l.function().maxArity(3),rebuild:l.function().arity(1),rules:l.object().pattern(p.nameRx,p.rule),terms:l.object().pattern(p.nameRx,l.object({init:l.array().allow(null).required(),manifest:l.object().pattern(/.+/,[l.valid("schema","single"),l.object({mapped:l.object({from:l.string().required(),to:l.string().required()}).required()})])})),validate:l.function().maxArity(3)}).strict(),$.extensions=l.array().items(l.object(),l.function().arity(1)).strict(),p.desc={buffer:l.object({buffer:l.string()}),func:l.object({function:l.function().required(),options:{literal:!0}}),override:l.object({override:!0}),ref:l.object({ref:l.object({type:l.valid("value","global","local"),path:l.array().required(),separator:l.string().length(1).allow(!1),ancestor:l.number().min(0).integer().allow("root"),map:l.array().items(l.array().length(2)).min(1),adjust:l.function(),iterables:l.boolean(),in:l.boolean(),render:l.boolean()}).required()}),regex:l.object({regex:l.string().min(3)}),special:l.object({special:l.valid("deep").required()}),template:l.object({template:l.string().required(),options:l.object()}),value:l.object({value:l.alternatives([l.object(),l.array()]).required()})},p.desc.entity=l.alternatives([l.array().items(l.link("...")),l.boolean(),l.function(),l.number(),l.string(),p.desc.buffer,p.desc.func,p.desc.ref,p.desc.regex,p.desc.special,p.desc.template,p.desc.value,l.link("/")]),p.desc.values=l.array().items(null,l.boolean(),l.function(),l.number().allow(1/0,-1/0),l.string().allow(""),l.symbol(),p.desc.buffer,p.desc.func,p.desc.override,p.desc.ref,p.desc.regex,p.desc.template,p.desc.value),p.desc.messages=l.object().pattern(/.+/,[l.string(),p.desc.template,l.object().pattern(/.+/,[l.string(),p.desc.template])]),$.description=l.object({type:l.string().required(),flags:l.object({cast:l.string(),default:l.any(),description:l.string(),empty:l.link("/"),failover:p.desc.entity,id:l.string(),label:l.string(),only:!0,presence:["optional","required","forbidden"],result:["raw","strip"],strip:l.boolean(),unit:l.string()}).unknown(),preferences:{allowUnknown:l.boolean(),abortEarly:l.boolean(),artifacts:l.boolean(),cache:l.boolean(),convert:l.boolean(),dateFormat:["date","iso","string","time","utc"],errors:{escapeHtml:l.boolean(),label:["path","key"],language:[l.string(),p.desc.ref],wrap:{label:p.wrap,array:p.wrap}},externals:l.boolean(),messages:p.desc.messages,noDefaults:l.boolean(),nonEnumerables:l.boolean(),presence:["required","optional","forbidden"],skipFunctions:l.boolean(),stripUnknown:l.object({arrays:l.boolean(),objects:l.boolean()}).or("arrays","objects").allow(!0,!1),warnings:l.boolean()},allow:p.desc.values,invalid:p.desc.values,rules:l.array().min(1).items({name:l.string().required(),args:l.object().min(1),keep:l.boolean(),message:[l.string(),p.desc.messages],warn:l.boolean()}),keys:l.object().pattern(/.*/,l.link("/")),link:p.desc.ref}).pattern(/^[a-z]\w*$/,l.any())},493:(k,$,b)=>{const l=b(8571),p=b(9621),g=b(8160),f={value:Symbol("value")};k.exports=f.State=class{constructor(t,n,a){this.path=t,this.ancestors=n,this.mainstay=a.mainstay,this.schemas=a.schemas,this.debug=null}localize(t,n=null,a=null){const r=new f.State(t,n,this);return a&&r.schemas&&(r.schemas=[f.schemas(a),...r.schemas]),r}nest(t,n){const a=new f.State(this.path,this.ancestors,this);return a.schemas=a.schemas&&[f.schemas(t),...a.schemas],a.debug=n,a}shadow(t,n){this.mainstay.shadow=this.mainstay.shadow||new f.Shadow,this.mainstay.shadow.set(this.path,t,n)}snapshot(){this.mainstay.shadow&&(this._snapshot=l(this.mainstay.shadow.node(this.path))),this.mainstay.snapshot()}restore(){this.mainstay.shadow&&(this.mainstay.shadow.override(this.path,this._snapshot),this._snapshot=void 0),this.mainstay.restore()}commit(){this.mainstay.shadow&&(this.mainstay.shadow.override(this.path,this._snapshot),this._snapshot=void 0),this.mainstay.commit()}},f.schemas=function(t){return g.isSchema(t)?{schema:t}:t},f.Shadow=class{constructor(){this._values=null}set(t,n,a){if(!t.length||a==="strip"&&typeof t[t.length-1]=="number")return;this._values=this._values||new Map;let r=this._values;for(let e=0;e<t.length;++e){const o=t[e];let s=r.get(o);s||(s=new Map,r.set(o,s)),r=s}r[f.value]=n}get(t){const n=this.node(t);if(n)return n[f.value]}node(t){if(this._values)return p(this._values,t,{iterables:!0})}override(t,n){if(!this._values)return;const a=t.slice(0,-1),r=t[t.length-1],e=p(this._values,a,{iterables:!0});n?e.set(r,n):e&&e.delete(r)}}},3328:(k,$,b)=>{const l=b(375),p=b(8571),g=b(5277),f=b(1447),t=b(8160),n=b(6354),a=b(6133),r={symbol:Symbol("template"),opens:new Array(1e3).join("\0"),closes:new Array(1e3).join(""),dateFormat:{date:Date.prototype.toDateString,iso:Date.prototype.toISOString,string:Date.prototype.toString,time:Date.prototype.toTimeString,utc:Date.prototype.toUTCString}};k.exports=r.Template=class{constructor(e,o){if(l(typeof e=="string","Template source must be a string"),l(!e.includes("\0")&&!e.includes(""),"Template source cannot contain reserved control characters"),this.source=e,this.rendered=e,this._template=null,o){const{functions:s,...i}=o;this._settings=Object.keys(i).length?p(i):void 0,this._functions=s,this._functions&&(l(Object.keys(this._functions).every(c=>typeof c=="string"),"Functions keys must be strings"),l(Object.values(this._functions).every(c=>typeof c=="function"),"Functions values must be functions"))}else this._settings=void 0,this._functions=void 0;this._parse()}_parse(){if(!this.source.includes("{"))return;const e=r.encode(this.source),o=r.split(e);let s=!1;const i=[],c=o.shift();c&&i.push(c);for(const m of o){const d=m[0]!=="{",_=d?"}":"}}",v=m.indexOf(_);if(v===-1||m[1]==="{"){i.push(`{${r.decode(m)}`);continue}let u=m.slice(d?0:1,v);const h=u[0]===":";h&&(u=u.slice(1));const y=this._ref(r.decode(u),{raw:d,wrapped:h});i.push(y),typeof y!="string"&&(s=!0);const w=m.slice(v+_.length);w&&i.push(r.decode(w))}s?this._template=i:this.rendered=i.join("")}static date(e,o){return r.dateFormat[o.dateFormat].call(e)}describe(e={}){if(!this._settings&&e.compact)return this.source;const o={template:this.source};return this._settings&&(o.options=this._settings),this._functions&&(o.functions=this._functions),o}static build(e){return new r.Template(e.template,e.options||e.functions?{...e.options,functions:e.functions}:void 0)}isDynamic(){return!!this._template}static isTemplate(e){return!!e&&!!e[t.symbols.template]}refs(){if(!this._template)return;const e=[];for(const o of this._template)typeof o!="string"&&e.push(...o.refs);return e}resolve(e,o,s,i){return this._template&&this._template.length===1?this._part(this._template[0],e,o,s,i,{}):this.render(e,o,s,i)}_part(e,...o){return e.ref?e.ref.resolve(...o):e.formula.evaluate(o)}render(e,o,s,i,c={}){if(!this.isDynamic())return this.rendered;const m=[];for(const d of this._template)if(typeof d=="string")m.push(d);else{const _=this._part(d,e,o,s,i,c),v=r.stringify(_,e,o,s,i,c);if(v!==void 0){const u=d.raw||(c.errors&&c.errors.escapeHtml)===!1?v:g(v);m.push(r.wrap(u,d.wrapped&&s.errors.wrap.label))}}return m.join("")}_ref(e,{raw:o,wrapped:s}){const i=[],c=d=>{const _=a.create(d,this._settings);return i.push(_),v=>{const u=_.resolve(...v);return u!==void 0?u:null}};try{const d=this._functions?{...r.functions,...this._functions}:r.functions;var m=new f.Parser(e,{reference:c,functions:d,constants:r.constants})}catch(d){throw d.message=`Invalid template variable "${e}" fails due to: ${d.message}`,d}if(m.single){if(m.single.type==="reference"){const d=i[0];return{ref:d,raw:o,refs:i,wrapped:s||d.type==="local"&&d.key==="label"}}return r.stringify(m.single.value)}return{formula:m,raw:o,refs:i}}toString(){return this.source}},r.Template.prototype[t.symbols.template]=!0,r.Template.prototype.isImmutable=!0,r.encode=function(e){return e.replace(/\\(\{+)/g,(o,s)=>r.opens.slice(0,s.length)).replace(/\\(\}+)/g,(o,s)=>r.closes.slice(0,s.length))},r.decode=function(e){return e.replace(/\u0000/g,"{").replace(/\u0001/g,"}")},r.split=function(e){const o=[];let s="";for(let i=0;i<e.length;++i){const c=e[i];if(c==="{"){let m="";for(;i+1<e.length&&e[i+1]==="{";)m+="{",++i;o.push(s),s=m}else s+=c}return o.push(s),o},r.wrap=function(e,o){return o?o.length===1?`${o}${e}${o}`:`${o[0]}${e}${o[1]}`:e},r.stringify=function(e,o,s,i,c,m={}){const d=typeof e,_=i&&i.errors&&i.errors.wrap||{};let v=!1;if(a.isRef(e)&&e.render&&(v=e.in,e=e.resolve(o,s,i,c,{in:e.in,...m})),e===null)return"null";if(d==="string")return r.wrap(e,m.arrayItems&&_.string);if(d==="number"||d==="function"||d==="symbol")return e.toString();if(d!=="object")return JSON.stringify(e);if(e instanceof Date)return r.Template.date(e,i);if(e instanceof Map){const h=[];for(const[y,w]of e.entries())h.push(`${y.toString()} -> ${w.toString()}`);e=h}if(!Array.isArray(e))return e.toString();const u=[];for(const h of e)u.push(r.stringify(h,o,s,i,c,{arrayItems:!0,...m}));return r.wrap(u.join(", "),!v&&_.array)},r.constants={true:!0,false:!1,null:null,second:1e3,minute:6e4,hour:36e5,day:864e5},r.functions={if:(e,o,s)=>e?o:s,length:e=>typeof e=="string"?e.length:e&&typeof e=="object"?Array.isArray(e)?e.length:Object.keys(e).length:null,msg(e){const[o,s,i,c,m]=this,d=m.messages;if(!d)return"";const _=n.template(o,d[0],e,s,i)||n.template(o,d[1],e,s,i);return _?_.render(o,s,i,c,m):""},number:e=>typeof e=="number"?e:typeof e=="string"?parseFloat(e):typeof e=="boolean"?e?1:0:e instanceof Date?e.getTime():null}},4946:(k,$,b)=>{const l=b(375),p=b(1687),g=b(8068),f=b(8160),t=b(3292),n=b(6354),a=b(6133),r={};k.exports=g.extend({type:"alternatives",flags:{match:{default:"any"}},terms:{matches:{init:[],register:a.toSibling}},args:(e,...o)=>o.length===1&&Array.isArray(o[0])?e.try(...o[0]):e.try(...o),validate(e,o){const{schema:s,error:i,state:c,prefs:m}=o;if(s._flags.match){const _=[],v=[];for(let h=0;h<s.$_terms.matches.length;++h){const y=s.$_terms.matches[h],w=c.nest(y.schema,`match.${h}`);w.snapshot();const x=y.schema.$_validate(e,w,m);x.errors?(v.push(x.errors),w.restore()):(_.push(x.value),w.commit())}if(_.length===0)return{errors:i("alternatives.any",{details:v.map(h=>n.details(h,{override:!1}))})};if(s._flags.match==="one")return _.length===1?{value:_[0]}:{errors:i("alternatives.one")};if(_.length!==s.$_terms.matches.length)return{errors:i("alternatives.all",{details:v.map(h=>n.details(h,{override:!1}))})};const u=h=>h.$_terms.matches.some(y=>y.schema.type==="object"||y.schema.type==="alternatives"&&u(y.schema));return u(s)?{value:_.reduce((h,y)=>p(h,y,{mergeArrays:!1}))}:{value:_[_.length-1]}}const d=[];for(let _=0;_<s.$_terms.matches.length;++_){const v=s.$_terms.matches[_];if(v.schema){const y=c.nest(v.schema,`match.${_}`);y.snapshot();const w=v.schema.$_validate(e,y,m);if(!w.errors)return y.commit(),w;y.restore(),d.push({schema:v.schema,reports:w.errors});continue}const u=v.ref?v.ref.resolve(e,c,m):e,h=v.is?[v]:v.switch;for(let y=0;y<h.length;++y){const w=h[y],{is:x,then:j,otherwise:S}=w,R=`match.${_}${v.switch?"."+y:""}`;if(x.$_match(u,c.nest(x,`${R}.is`),m)){if(j)return j.$_validate(e,c.nest(j,`${R}.then`),m)}else if(S)return S.$_validate(e,c.nest(S,`${R}.otherwise`),m)}}return r.errors(d,o)},rules:{conditional:{method(e,o){l(!this._flags._endedSwitch,"Unreachable condition"),l(!this._flags.match,"Cannot combine match mode",this._flags.match,"with conditional rule"),l(o.break===void 0,"Cannot use break option with alternatives conditional");const s=this.clone(),i=t.when(s,e,o),c=i.is?[i]:i.switch;for(const m of c)if(m.then&&m.otherwise){s.$_setFlag("_endedSwitch",!0,{clone:!1});break}return s.$_terms.matches.push(i),s.$_mutateRebuild()}},match:{method(e){if(l(["any","one","all"].includes(e),"Invalid alternatives match mode",e),e!=="any")for(const o of this.$_terms.matches)l(o.schema,"Cannot combine match mode",e,"with conditional rules");return this.$_setFlag("match",e)}},try:{method(...e){l(e.length,"Missing alternative schemas"),f.verifyFlat(e,"try"),l(!this._flags._endedSwitch,"Unreachable condition");const o=this.clone();for(const s of e)o.$_terms.matches.push({schema:o.$_compile(s)});return o.$_mutateRebuild()}}},overrides:{label(e){return this.$_parent("label",e).$_modify({each:(o,s)=>s.path[0]!=="is"&&typeof o._flags.label!="string"?o.label(e):void 0,ref:!1})}},rebuild(e){e.$_modify({each:o=>{f.isSchema(o)&&o.type==="array"&&e.$_setFlag("_arrayItems",!0,{clone:!1})}})},manifest:{build(e,o){if(o.matches)for(const s of o.matches){const{schema:i,ref:c,is:m,not:d,then:_,otherwise:v}=s;e=i?e.try(i):c?e.conditional(c,{is:m,then:_,not:d,otherwise:v,switch:s.switch}):e.conditional(m,{then:_,otherwise:v})}return e}},messages:{"alternatives.all":"{{#label}} does not match all of the required types","alternatives.any":"{{#label}} does not match any of the allowed types","alternatives.match":"{{#label}} does not match any of the allowed types","alternatives.one":"{{#label}} matches more than one allowed type","alternatives.types":"{{#label}} must be one of {{#types}}"}}),r.errors=function(e,{error:o,state:s}){if(!e.length)return{errors:o("alternatives.any")};if(e.length===1)return{errors:e[0].reports};const i=new Set,c=[];for(const{reports:m,schema:d}of e){if(m.length>1)return r.unmatched(e,o);const _=m[0];if(_ instanceof n.Report==0)return r.unmatched(e,o);if(_.state.path.length!==s.path.length){c.push({type:d.type,report:_});continue}if(_.code==="any.only"){for(const h of _.local.valids)i.add(h);continue}const[v,u]=_.code.split(".");u==="base"?i.add(v):c.push({type:d.type,report:_})}return c.length?c.length===1?{errors:c[0].report}:r.unmatched(e,o):{errors:o("alternatives.types",{types:[...i]})}},r.unmatched=function(e,o){const s=[];for(const i of e)s.push(...i.reports);return{errors:o("alternatives.match",n.details(s,{override:!1}))}}},8068:(k,$,b)=>{const l=b(375),p=b(7629),g=b(8160),f=b(6914);k.exports=p.extend({type:"any",flags:{only:{default:!1}},terms:{alterations:{init:null},examples:{init:null},externals:{init:null},metas:{init:[]},notes:{init:[]},shared:{init:null},tags:{init:[]},whens:{init:null}},rules:{custom:{method(t,n){return l(typeof t=="function","Method must be a function"),l(n===void 0||n&&typeof n=="string","Description must be a non-empty string"),this.$_addRule({name:"custom",args:{method:t,description:n}})},validate(t,n,{method:a}){try{return a(t,n)}catch(r){return n.error("any.custom",{error:r})}},args:["method","description"],multi:!0},messages:{method(t){return this.prefs({messages:t})}},shared:{method(t){l(g.isSchema(t)&&t._flags.id,"Schema must be a schema with an id");const n=this.clone();return n.$_terms.shared=n.$_terms.shared||[],n.$_terms.shared.push(t),n.$_mutateRegister(t),n}},warning:{method(t,n){return l(t&&typeof t=="string","Invalid warning code"),this.$_addRule({name:"warning",args:{code:t,local:n},warn:!0})},validate:(t,n,{code:a,local:r})=>n.error(a,r),args:["code","local"],multi:!0}},modifiers:{keep(t,n=!0){t.keep=n},message(t,n){t.message=f.compile(n)},warn(t,n=!0){t.warn=n}},manifest:{build(t,n){for(const a in n){const r=n[a];if(["examples","externals","metas","notes","tags"].includes(a))for(const e of r)t=t[a.slice(0,-1)](e);else if(a!=="alterations")if(a!=="whens"){if(a==="shared")for(const e of r)t=t.shared(e)}else for(const e of r){const{ref:o,is:s,not:i,then:c,otherwise:m,concat:d}=e;t=d?t.concat(d):o?t.when(o,{is:s,not:i,then:c,otherwise:m,switch:e.switch,break:e.break}):t.when(s,{then:c,otherwise:m,break:e.break})}else{const e={};for(const{target:o,adjuster:s}of r)e[o]=s;t=t.alter(e)}}return t}},messages:{"any.custom":"{{#label}} failed custom validation because {{#error.message}}","any.default":"{{#label}} threw an error when running default method","any.failover":"{{#label}} threw an error when running failover method","any.invalid":"{{#label}} contains an invalid value","any.only":'{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',"any.ref":"{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}","any.required":"{{#label}} is required","any.unknown":"{{#label}} is not allowed"}})},546:(k,$,b)=>{const l=b(375),p=b(9474),g=b(9621),f=b(8068),t=b(8160),n=b(3292),a={};k.exports=f.extend({type:"array",flags:{single:{default:!1},sparse:{default:!1}},terms:{items:{init:[],manifest:"schema"},ordered:{init:[],manifest:"schema"},_exclusions:{init:[]},_inclusions:{init:[]},_requireds:{init:[]}},coerce:{from:"object",method(r,{schema:e,state:o,prefs:s}){if(!Array.isArray(r))return;const i=e.$_getRule("sort");return i?a.sort(e,r,i.args.options,o,s):void 0}},validate(r,{schema:e,error:o}){if(!Array.isArray(r)){if(e._flags.single){const s=[r];return s[t.symbols.arraySingle]=!0,{value:s}}return{errors:o("array.base")}}if(e.$_getRule("items")||e.$_terms.externals)return{value:r.slice()}},rules:{has:{method(r){r=this.$_compile(r,{appendPath:!0});const e=this.$_addRule({name:"has",args:{schema:r}});return e.$_mutateRegister(r),e},validate(r,{state:e,prefs:o,error:s},{schema:i}){const c=[r,...e.ancestors];for(let d=0;d<r.length;++d){const _=e.localize([...e.path,d],c,i);if(i.$_match(r[d],_,o))return r}const m=i._flags.label;return m?s("array.hasKnown",{patternLabel:m}):s("array.hasUnknown",null)},multi:!0},items:{method(...r){t.verifyFlat(r,"items");const e=this.$_addRule("items");for(let o=0;o<r.length;++o){const s=t.tryWithPath(()=>this.$_compile(r[o]),o,{append:!0});e.$_terms.items.push(s)}return e.$_mutateRebuild()},validate(r,{schema:e,error:o,state:s,prefs:i,errorsArray:c}){const m=e.$_terms._requireds.slice(),d=e.$_terms.ordered.slice(),_=[...e.$_terms._inclusions,...m],v=!r[t.symbols.arraySingle];delete r[t.symbols.arraySingle];const u=c();let h=r.length;for(let y=0;y<h;++y){const w=r[y];let x=!1,j=!1;const S=v?y:new Number(y),R=[...s.path,S];if(!e._flags.sparse&&w===void 0){if(u.push(o("array.sparse",{key:S,path:R,pos:y,value:void 0},s.localize(R))),i.abortEarly)return u;d.shift();continue}const O=[r,...s.ancestors];for(const M of e.$_terms._exclusions)if(M.$_match(w,s.localize(R,O,M),i,{presence:"ignore"})){if(u.push(o("array.excludes",{pos:y,value:w},s.localize(R))),i.abortEarly)return u;x=!0,d.shift();break}if(x)continue;if(e.$_terms.ordered.length){if(d.length){const M=d.shift(),E=M.$_validate(w,s.localize(R,O,M),i);if(E.errors){if(u.push(...E.errors),i.abortEarly)return u}else if(M._flags.result==="strip")a.fastSplice(r,y),--y,--h;else{if(!e._flags.sparse&&E.value===void 0){if(u.push(o("array.sparse",{key:S,path:R,pos:y,value:void 0},s.localize(R))),i.abortEarly)return u;continue}r[y]=E.value}continue}if(!e.$_terms.items.length){if(u.push(o("array.orderedLength",{pos:y,limit:e.$_terms.ordered.length})),i.abortEarly)return u;break}}const D=[];let L=m.length;for(let M=0;M<L;++M){const E=s.localize(R,O,m[M]);E.snapshot();const T=m[M].$_validate(w,E,i);if(D[M]=T,!T.errors){if(E.commit(),r[y]=T.value,j=!0,a.fastSplice(m,M),--M,--L,!e._flags.sparse&&T.value===void 0&&(u.push(o("array.sparse",{key:S,path:R,pos:y,value:void 0},s.localize(R))),i.abortEarly))return u;break}E.restore()}if(j)continue;const z=i.stripUnknown&&!!i.stripUnknown.arrays||!1;L=_.length;for(const M of _){let E;const T=m.indexOf(M);if(T!==-1)E=D[T];else{const P=s.localize(R,O,M);if(P.snapshot(),E=M.$_validate(w,P,i),!E.errors){P.commit(),M._flags.result==="strip"?(a.fastSplice(r,y),--y,--h):e._flags.sparse||E.value!==void 0?r[y]=E.value:(u.push(o("array.sparse",{key:S,path:R,pos:y,value:void 0},s.localize(R))),x=!0),j=!0;break}P.restore()}if(L===1){if(z){a.fastSplice(r,y),--y,--h,j=!0;break}if(u.push(...E.errors),i.abortEarly)return u;x=!0;break}}if(!x&&(e.$_terms._inclusions.length||e.$_terms._requireds.length)&&!j){if(z){a.fastSplice(r,y),--y,--h;continue}if(u.push(o("array.includes",{pos:y,value:w},s.localize(R))),i.abortEarly)return u}}return m.length&&a.fillMissedErrors(e,u,m,r,s,i),d.length&&(a.fillOrderedErrors(e,u,d,r,s,i),u.length||a.fillDefault(d,r,s,i)),u.length?u:r},priority:!0,manifest:!1},length:{method(r){return this.$_addRule({name:"length",args:{limit:r},operator:"="})},validate:(r,e,{limit:o},{name:s,operator:i,args:c})=>t.compare(r.length,o,i)?r:e.error("array."+s,{limit:c.limit,value:r}),args:[{name:"limit",ref:!0,assert:t.limit,message:"must be a positive integer"}]},max:{method(r){return this.$_addRule({name:"max",method:"length",args:{limit:r},operator:"<="})}},min:{method(r){return this.$_addRule({name:"min",method:"length",args:{limit:r},operator:">="})}},ordered:{method(...r){t.verifyFlat(r,"ordered");const e=this.$_addRule("items");for(let o=0;o<r.length;++o){const s=t.tryWithPath(()=>this.$_compile(r[o]),o,{append:!0});a.validateSingle(s,e),e.$_mutateRegister(s),e.$_terms.ordered.push(s)}return e.$_mutateRebuild()}},single:{method(r){const e=r===void 0||!!r;return l(!e||!this._flags._arrayItems,"Cannot specify single rule when array has array items"),this.$_setFlag("single",e)}},sort:{method(r={}){t.assertOptions(r,["by","order"]);const e={order:r.order||"ascending"};return r.by&&(e.by=n.ref(r.by,{ancestor:0}),l(!e.by.ancestor,"Cannot sort by ancestor")),this.$_addRule({name:"sort",args:{options:e}})},validate(r,{error:e,state:o,prefs:s,schema:i},{options:c}){const{value:m,errors:d}=a.sort(i,r,c,o,s);if(d)return d;for(let _=0;_<r.length;++_)if(r[_]!==m[_])return e("array.sort",{order:c.order,by:c.by?c.by.key:"value"});return r},convert:!0},sparse:{method(r){const e=r===void 0||!!r;return this._flags.sparse===e?this:(e?this.clone():this.$_addRule("items")).$_setFlag("sparse",e,{clone:!1})}},unique:{method(r,e={}){l(!r||typeof r=="function"||typeof r=="string","comparator must be a function or a string"),t.assertOptions(e,["ignoreUndefined","separator"]);const o={name:"unique",args:{options:e,comparator:r}};if(r)if(typeof r=="string"){const s=t.default(e.separator,".");o.path=s?r.split(s):[r]}else o.comparator=r;return this.$_addRule(o)},validate(r,{state:e,error:o,schema:s},{comparator:i,options:c},{comparator:m,path:d}){const _={string:Object.create(null),number:Object.create(null),undefined:Object.create(null),boolean:Object.create(null),object:new Map,function:new Map,custom:new Map},v=m||p,u=c.ignoreUndefined;for(let h=0;h<r.length;++h){const y=d?g(r[h],d):r[h],w=m?_.custom:_[typeof y];if(l(w,"Failed to find unique map container for type",typeof y),w instanceof Map){const x=w.entries();let j;for(;!(j=x.next()).done;)if(v(j.value[0],y)){const S=e.localize([...e.path,h],[r,...e.ancestors]),R={pos:h,value:r[h],dupePos:j.value[1],dupeValue:r[j.value[1]]};return d&&(R.path=i),o("array.unique",R,S)}w.set(y,h)}else{if((!u||y!==void 0)&&w[y]!==void 0){const x={pos:h,value:r[h],dupePos:w[y],dupeValue:r[w[y]]};return d&&(x.path=i),o("array.unique",x,e.localize([...e.path,h],[r,...e.ancestors]))}w[y]=h}}return r},args:["comparator","options"],multi:!0}},cast:{set:{from:Array.isArray,to:(r,e)=>new Set(r)}},rebuild(r){r.$_terms._inclusions=[],r.$_terms._exclusions=[],r.$_terms._requireds=[];for(const e of r.$_terms.items)a.validateSingle(e,r),e._flags.presence==="required"?r.$_terms._requireds.push(e):e._flags.presence==="forbidden"?r.$_terms._exclusions.push(e):r.$_terms._inclusions.push(e);for(const e of r.$_terms.ordered)a.validateSingle(e,r)},manifest:{build:(r,e)=>(e.items&&(r=r.items(...e.items)),e.ordered&&(r=r.ordered(...e.ordered)),r)},messages:{"array.base":"{{#label}} must be an array","array.excludes":"{{#label}} contains an excluded value","array.hasKnown":"{{#label}} does not contain at least one required match for type {:#patternLabel}","array.hasUnknown":"{{#label}} does not contain at least one required match","array.includes":"{{#label}} does not match any of the allowed types","array.includesRequiredBoth":"{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)","array.includesRequiredKnowns":"{{#label}} does not contain {{#knownMisses}}","array.includesRequiredUnknowns":"{{#label}} does not contain {{#unknownMisses}} required value(s)","array.length":"{{#label}} must contain {{#limit}} items","array.max":"{{#label}} must contain less than or equal to {{#limit}} items","array.min":"{{#label}} must contain at least {{#limit}} items","array.orderedLength":"{{#label}} must contain at most {{#limit}} items","array.sort":"{{#label}} must be sorted in {#order} order by {{#by}}","array.sort.mismatching":"{{#label}} cannot be sorted due to mismatching types","array.sort.unsupported":"{{#label}} cannot be sorted due to unsupported type {#type}","array.sparse":"{{#label}} must not be a sparse array item","array.unique":"{{#label}} contains a duplicate value"}}),a.fillMissedErrors=function(r,e,o,s,i,c){const m=[];let d=0;for(const _ of o){const v=_._flags.label;v?m.push(v):++d}m.length?d?e.push(r.$_createError("array.includesRequiredBoth",s,{knownMisses:m,unknownMisses:d},i,c)):e.push(r.$_createError("array.includesRequiredKnowns",s,{knownMisses:m},i,c)):e.push(r.$_createError("array.includesRequiredUnknowns",s,{unknownMisses:d},i,c))},a.fillOrderedErrors=function(r,e,o,s,i,c){const m=[];for(const d of o)d._flags.presence==="required"&&m.push(d);m.length&&a.fillMissedErrors(r,e,m,s,i,c)},a.fillDefault=function(r,e,o,s){const i=[];let c=!0;for(let m=r.length-1;m>=0;--m){const d=r[m],_=[e,...o.ancestors],v=d.$_validate(void 0,o.localize(o.path,_,d),s).value;if(c){if(v===void 0)continue;c=!1}i.unshift(v)}i.length&&e.push(...i)},a.fastSplice=function(r,e){let o=e;for(;o<r.length;)r[o++]=r[o];--r.length},a.validateSingle=function(r,e){(r.type==="array"||r._flags._arrayItems)&&(l(!e._flags.single,"Cannot specify array item with single rule enabled"),e.$_setFlag("_arrayItems",!0,{clone:!1}))},a.sort=function(r,e,o,s,i){const c=o.order==="ascending"?1:-1,m=-1*c,d=c,_=(v,u)=>{let h=a.compare(v,u,m,d);if(h!==null||(o.by&&(v=o.by.resolve(v,s,i),u=o.by.resolve(u,s,i)),h=a.compare(v,u,m,d),h!==null))return h;const y=typeof v;if(y!==typeof u)throw r.$_createError("array.sort.mismatching",e,null,s,i);if(y!=="number"&&y!=="string")throw r.$_createError("array.sort.unsupported",e,{type:y},s,i);return y==="number"?(v-u)*c:v<u?m:d};try{return{value:e.slice().sort(_)}}catch(v){return{errors:v}}},a.compare=function(r,e,o,s){return r===e?0:r===void 0?1:e===void 0?-1:r===null?s:e===null?o:null}},4937:(k,$,b)=>{const l=b(375),p=b(8068),g=b(8160),f=b(2036),t={isBool:function(n){return typeof n=="boolean"}};k.exports=p.extend({type:"boolean",flags:{sensitive:{default:!1}},terms:{falsy:{init:null,manifest:"values"},truthy:{init:null,manifest:"values"}},coerce(n,{schema:a}){if(typeof n!="boolean"){if(typeof n=="string"){const r=a._flags.sensitive?n:n.toLowerCase();n=r==="true"||r!=="false"&&n}return typeof n!="boolean"&&(n=a.$_terms.truthy&&a.$_terms.truthy.has(n,null,null,!a._flags.sensitive)||(!a.$_terms.falsy||!a.$_terms.falsy.has(n,null,null,!a._flags.sensitive))&&n),{value:n}}},validate(n,{error:a}){if(typeof n!="boolean")return{value:n,errors:a("boolean.base")}},rules:{truthy:{method(...n){g.verifyFlat(n,"truthy");const a=this.clone();a.$_terms.truthy=a.$_terms.truthy||new f;for(let r=0;r<n.length;++r){const e=n[r];l(e!==void 0,"Cannot call truthy with undefined"),a.$_terms.truthy.add(e)}return a}},falsy:{method(...n){g.verifyFlat(n,"falsy");const a=this.clone();a.$_terms.falsy=a.$_terms.falsy||new f;for(let r=0;r<n.length;++r){const e=n[r];l(e!==void 0,"Cannot call falsy with undefined"),a.$_terms.falsy.add(e)}return a}},sensitive:{method(n=!0){return this.$_setFlag("sensitive",n)}}},cast:{number:{from:t.isBool,to:(n,a)=>n?1:0},string:{from:t.isBool,to:(n,a)=>n?"true":"false"}},manifest:{build:(n,a)=>(a.truthy&&(n=n.truthy(...a.truthy)),a.falsy&&(n=n.falsy(...a.falsy)),n)},messages:{"boolean.base":"{{#label}} must be a boolean"}})},7500:(k,$,b)=>{const l=b(375),p=b(8068),g=b(8160),f=b(3328),t={isDate:function(n){return n instanceof Date}};k.exports=p.extend({type:"date",coerce:{from:["number","string"],method:(n,{schema:a})=>({value:t.parse(n,a._flags.format)||n})},validate(n,{schema:a,error:r,prefs:e}){if(n instanceof Date&&!isNaN(n.getTime()))return;const o=a._flags.format;return e.convert&&o&&typeof n=="string"?{value:n,errors:r("date.format",{format:o})}:{value:n,errors:r("date.base")}},rules:{compare:{method:!1,validate(n,a,{date:r},{name:e,operator:o,args:s}){const i=r==="now"?Date.now():r.getTime();return g.compare(n.getTime(),i,o)?n:a.error("date."+e,{limit:s.date,value:n})},args:[{name:"date",ref:!0,normalize:n=>n==="now"?n:t.parse(n),assert:n=>n!==null,message:"must have a valid date format"}]},format:{method(n){return l(["iso","javascript","unix"].includes(n),"Unknown date format",n),this.$_setFlag("format",n)}},greater:{method(n){return this.$_addRule({name:"greater",method:"compare",args:{date:n},operator:">"})}},iso:{method(){return this.format("iso")}},less:{method(n){return this.$_addRule({name:"less",method:"compare",args:{date:n},operator:"<"})}},max:{method(n){return this.$_addRule({name:"max",method:"compare",args:{date:n},operator:"<="})}},min:{method(n){return this.$_addRule({name:"min",method:"compare",args:{date:n},operator:">="})}},timestamp:{method(n="javascript"){return l(["javascript","unix"].includes(n),'"type" must be one of "javascript, unix"'),this.format(n)}}},cast:{number:{from:t.isDate,to:(n,a)=>n.getTime()},string:{from:t.isDate,to:(n,{prefs:a})=>f.date(n,a)}},messages:{"date.base":"{{#label}} must be a valid date","date.format":'{{#label}} must be in {msg("date.format." + #format) || #format} format',"date.greater":"{{#label}} must be greater than {{:#limit}}","date.less":"{{#label}} must be less than {{:#limit}}","date.max":"{{#label}} must be less than or equal to {{:#limit}}","date.min":"{{#label}} must be greater than or equal to {{:#limit}}","date.format.iso":"ISO 8601 date","date.format.javascript":"timestamp or number of milliseconds","date.format.unix":"timestamp or number of seconds"}}),t.parse=function(n,a){if(n instanceof Date)return n;if(typeof n!="string"&&(isNaN(n)||!isFinite(n))||/^\s*$/.test(n))return null;if(a==="iso")return g.isIsoDate(n)?t.date(n.toString()):null;const r=n;if(typeof n=="string"&&/^[+-]?\d+(\.\d+)?$/.test(n)&&(n=parseFloat(n)),a){if(a==="javascript")return t.date(1*n);if(a==="unix")return t.date(1e3*n);if(typeof r=="string")return null}return t.date(n)},t.date=function(n){const a=new Date(n);return isNaN(a.getTime())?null:a}},390:(k,$,b)=>{const l=b(375),p=b(7824);k.exports=p.extend({type:"function",properties:{typeof:"function"},rules:{arity:{method(g){return l(Number.isSafeInteger(g)&&g>=0,"n must be a positive integer"),this.$_addRule({name:"arity",args:{n:g}})},validate:(g,f,{n:t})=>g.length===t?g:f.error("function.arity",{n:t})},class:{method(){return this.$_addRule("class")},validate:(g,f)=>/^\s*class\s/.test(g.toString())?g:f.error("function.class",{value:g})},minArity:{method(g){return l(Number.isSafeInteger(g)&&g>0,"n must be a strict positive integer"),this.$_addRule({name:"minArity",args:{n:g}})},validate:(g,f,{n:t})=>g.length>=t?g:f.error("function.minArity",{n:t})},maxArity:{method(g){return l(Number.isSafeInteger(g)&&g>=0,"n must be a positive integer"),this.$_addRule({name:"maxArity",args:{n:g}})},validate:(g,f,{n:t})=>g.length<=t?g:f.error("function.maxArity",{n:t})}},messages:{"function.arity":"{{#label}} must have an arity of {{#n}}","function.class":"{{#label}} must be a class","function.maxArity":"{{#label}} must have an arity lesser or equal to {{#n}}","function.minArity":"{{#label}} must have an arity greater or equal to {{#n}}"}})},7824:(k,$,b)=>{const l=b(978),p=b(375),g=b(8571),f=b(3652),t=b(8068),n=b(8160),a=b(3292),r=b(6354),e=b(6133),o=b(3328),s={renameDefaults:{alias:!1,multiple:!1,override:!1}};k.exports=t.extend({type:"_keys",properties:{typeof:"object"},flags:{unknown:{default:!1}},terms:{dependencies:{init:null},keys:{init:null,manifest:{mapped:{from:"schema",to:"key"}}},patterns:{init:null},renames:{init:null}},args:(i,c)=>i.keys(c),validate(i,{schema:c,error:m,state:d,prefs:_}){if(!i||typeof i!==c.$_property("typeof")||Array.isArray(i))return{value:i,errors:m("object.base",{type:c.$_property("typeof")})};if(!(c.$_terms.renames||c.$_terms.dependencies||c.$_terms.keys||c.$_terms.patterns||c.$_terms.externals))return;i=s.clone(i,_);const v=[];if(c.$_terms.renames&&!s.rename(c,i,d,_,v))return{value:i,errors:v};if(!c.$_terms.keys&&!c.$_terms.patterns&&!c.$_terms.dependencies)return{value:i,errors:v};const u=new Set(Object.keys(i));if(c.$_terms.keys){const h=[i,...d.ancestors];for(const y of c.$_terms.keys){const w=y.key,x=i[w];u.delete(w);const j=d.localize([...d.path,w],h,y),S=y.schema.$_validate(x,j,_);if(S.errors){if(_.abortEarly)return{value:i,errors:S.errors};S.value!==void 0&&(i[w]=S.value),v.push(...S.errors)}else y.schema._flags.result==="strip"||S.value===void 0&&x!==void 0?delete i[w]:S.value!==void 0&&(i[w]=S.value)}}if(u.size||c._flags._hasPatternMatch){const h=s.unknown(c,i,u,v,d,_);if(h)return h}if(c.$_terms.dependencies)for(const h of c.$_terms.dependencies){if(h.key!==null&&s.isPresent(h.options)(h.key.resolve(i,d,_,null,{shadow:!1}))===!1)continue;const y=s.dependencies[h.rel](c,h,i,d,_);if(y){const w=c.$_createError(y.code,i,y.context,d,_);if(_.abortEarly)return{value:i,errors:w};v.push(w)}}return{value:i,errors:v}},rules:{and:{method(...i){return n.verifyFlat(i,"and"),s.dependency(this,"and",null,i)}},append:{method(i){return i==null||Object.keys(i).length===0?this:this.keys(i)}},assert:{method(i,c,m){o.isTemplate(i)||(i=a.ref(i)),p(m===void 0||typeof m=="string","Message must be a string"),c=this.$_compile(c,{appendPath:!0});const d=this.$_addRule({name:"assert",args:{subject:i,schema:c,message:m}});return d.$_mutateRegister(i),d.$_mutateRegister(c),d},validate(i,{error:c,prefs:m,state:d},{subject:_,schema:v,message:u}){const h=_.resolve(i,d,m),y=e.isRef(_)?_.absolute(d):[];return v.$_match(h,d.localize(y,[i,...d.ancestors],v),m)?i:c("object.assert",{subject:_,message:u})},args:["subject","schema","message"],multi:!0},instance:{method(i,c){return p(typeof i=="function","constructor must be a function"),c=c||i.name,this.$_addRule({name:"instance",args:{constructor:i,name:c}})},validate:(i,c,{constructor:m,name:d})=>i instanceof m?i:c.error("object.instance",{type:d,value:i}),args:["constructor","name"]},keys:{method(i){p(i===void 0||typeof i=="object","Object schema must be a valid object"),p(!n.isSchema(i),"Object schema cannot be a joi schema");const c=this.clone();if(i)if(Object.keys(i).length){c.$_terms.keys=c.$_terms.keys?c.$_terms.keys.filter(m=>!i.hasOwnProperty(m.key)):new s.Keys;for(const m in i)n.tryWithPath(()=>c.$_terms.keys.push({key:m,schema:this.$_compile(i[m])}),m)}else c.$_terms.keys=new s.Keys;else c.$_terms.keys=null;return c.$_mutateRebuild()}},length:{method(i){return this.$_addRule({name:"length",args:{limit:i},operator:"="})},validate:(i,c,{limit:m},{name:d,operator:_,args:v})=>n.compare(Object.keys(i).length,m,_)?i:c.error("object."+d,{limit:v.limit,value:i}),args:[{name:"limit",ref:!0,assert:n.limit,message:"must be a positive integer"}]},max:{method(i){return this.$_addRule({name:"max",method:"length",args:{limit:i},operator:"<="})}},min:{method(i){return this.$_addRule({name:"min",method:"length",args:{limit:i},operator:">="})}},nand:{method(...i){return n.verifyFlat(i,"nand"),s.dependency(this,"nand",null,i)}},or:{method(...i){return n.verifyFlat(i,"or"),s.dependency(this,"or",null,i)}},oxor:{method(...i){return s.dependency(this,"oxor",null,i)}},pattern:{method(i,c,m={}){const d=i instanceof RegExp;d||(i=this.$_compile(i,{appendPath:!0})),p(c!==void 0,"Invalid rule"),n.assertOptions(m,["fallthrough","matches"]),d&&p(!i.flags.includes("g")&&!i.flags.includes("y"),"pattern should not use global or sticky mode"),c=this.$_compile(c,{appendPath:!0});const _=this.clone();_.$_terms.patterns=_.$_terms.patterns||[];const v={[d?"regex":"schema"]:i,rule:c};return m.matches&&(v.matches=this.$_compile(m.matches),v.matches.type!=="array"&&(v.matches=v.matches.$_root.array().items(v.matches)),_.$_mutateRegister(v.matches),_.$_setFlag("_hasPatternMatch",!0,{clone:!1})),m.fallthrough&&(v.fallthrough=!0),_.$_terms.patterns.push(v),_.$_mutateRegister(c),_}},ref:{method(){return this.$_addRule("ref")},validate:(i,c)=>e.isRef(i)?i:c.error("object.refType",{value:i})},regex:{method(){return this.$_addRule("regex")},validate:(i,c)=>i instanceof RegExp?i:c.error("object.regex",{value:i})},rename:{method(i,c,m={}){p(typeof i=="string"||i instanceof RegExp,"Rename missing the from argument"),p(typeof c=="string"||c instanceof o,"Invalid rename to argument"),p(c!==i,"Cannot rename key to same name:",i),n.assertOptions(m,["alias","ignoreUndefined","override","multiple"]);const d=this.clone();d.$_terms.renames=d.$_terms.renames||[];for(const _ of d.$_terms.renames)p(_.from!==i,"Cannot rename the same key multiple times");return c instanceof o&&d.$_mutateRegister(c),d.$_terms.renames.push({from:i,to:c,options:l(s.renameDefaults,m)}),d}},schema:{method(i="any"){return this.$_addRule({name:"schema",args:{type:i}})},validate:(i,c,{type:m})=>!n.isSchema(i)||m!=="any"&&i.type!==m?c.error("object.schema",{type:m}):i},unknown:{method(i){return this.$_setFlag("unknown",i!==!1)}},with:{method(i,c,m={}){return s.dependency(this,"with",i,c,m)}},without:{method(i,c,m={}){return s.dependency(this,"without",i,c,m)}},xor:{method(...i){return n.verifyFlat(i,"xor"),s.dependency(this,"xor",null,i)}}},overrides:{default(i,c){return i===void 0&&(i=n.symbols.deepDefault),this.$_parent("default",i,c)}},rebuild(i){if(i.$_terms.keys){const c=new f.Sorter;for(const m of i.$_terms.keys)n.tryWithPath(()=>c.add(m,{after:m.schema.$_rootReferences(),group:m.key}),m.key);i.$_terms.keys=new s.Keys(...c.nodes)}},manifest:{build(i,c){if(c.keys&&(i=i.keys(c.keys)),c.dependencies)for(const{rel:m,key:d=null,peers:_,options:v}of c.dependencies)i=s.dependency(i,m,d,_,v);if(c.patterns)for(const{regex:m,schema:d,rule:_,fallthrough:v,matches:u}of c.patterns)i=i.pattern(m||d,_,{fallthrough:v,matches:u});if(c.renames)for(const{from:m,to:d,options:_}of c.renames)i=i.rename(m,d,_);return i}},messages:{"object.and":"{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}","object.assert":'{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',"object.base":"{{#label}} must be of type {{#type}}","object.instance":"{{#label}} must be an instance of {{:#type}}","object.length":'{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',"object.max":'{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',"object.min":'{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',"object.missing":"{{#label}} must contain at least one of {{#peersWithLabels}}","object.nand":"{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}","object.oxor":"{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}","object.pattern.match":"{{#label}} keys failed to match pattern requirements","object.refType":"{{#label}} must be a Joi reference","object.regex":"{{#label}} must be a RegExp object","object.rename.multiple":"{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}","object.rename.override":"{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists","object.schema":"{{#label}} must be a Joi schema of {{#type}} type","object.unknown":"{{#label}} is not allowed","object.with":"{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}","object.without":"{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}","object.xor":"{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"}}),s.clone=function(i,c){if(typeof i=="object"){if(c.nonEnumerables)return g(i,{shallow:!0});const d=Object.create(Object.getPrototypeOf(i));return Object.assign(d,i),d}const m=function(...d){return i.apply(this,d)};return m.prototype=g(i.prototype),Object.defineProperty(m,"name",{value:i.name,writable:!1}),Object.defineProperty(m,"length",{value:i.length,writable:!1}),Object.assign(m,i),m},s.dependency=function(i,c,m,d,_){p(m===null||typeof m=="string",c,"key must be a strings"),_||(_=d.length>1&&typeof d[d.length-1]=="object"?d.pop():{}),n.assertOptions(_,["separator","isPresent"]),d=[].concat(d);const v=n.default(_.separator,"."),u=[];for(const y of d)p(typeof y=="string",c,"peers must be strings"),u.push(a.ref(y,{separator:v,ancestor:0,prefix:!1}));m!==null&&(m=a.ref(m,{separator:v,ancestor:0,prefix:!1}));const h=i.clone();return h.$_terms.dependencies=h.$_terms.dependencies||[],h.$_terms.dependencies.push(new s.Dependency(c,m,u,d,_)),h},s.dependencies={and(i,c,m,d,_){const v=[],u=[],h=c.peers.length,y=s.isPresent(c.options);for(const w of c.peers)y(w.resolve(m,d,_,null,{shadow:!1}))===!1?v.push(w.key):u.push(w.key);if(v.length!==h&&u.length!==h)return{code:"object.and",context:{present:u,presentWithLabels:s.keysToLabels(i,u),missing:v,missingWithLabels:s.keysToLabels(i,v)}}},nand(i,c,m,d,_){const v=[],u=s.isPresent(c.options);for(const w of c.peers)u(w.resolve(m,d,_,null,{shadow:!1}))&&v.push(w.key);if(v.length!==c.peers.length)return;const h=c.paths[0],y=c.paths.slice(1);return{code:"object.nand",context:{main:h,mainWithLabel:s.keysToLabels(i,h),peers:y,peersWithLabels:s.keysToLabels(i,y)}}},or(i,c,m,d,_){const v=s.isPresent(c.options);for(const u of c.peers)if(v(u.resolve(m,d,_,null,{shadow:!1})))return;return{code:"object.missing",context:{peers:c.paths,peersWithLabels:s.keysToLabels(i,c.paths)}}},oxor(i,c,m,d,_){const v=[],u=s.isPresent(c.options);for(const y of c.peers)u(y.resolve(m,d,_,null,{shadow:!1}))&&v.push(y.key);if(!v.length||v.length===1)return;const h={peers:c.paths,peersWithLabels:s.keysToLabels(i,c.paths)};return h.present=v,h.presentWithLabels=s.keysToLabels(i,v),{code:"object.oxor",context:h}},with(i,c,m,d,_){const v=s.isPresent(c.options);for(const u of c.peers)if(v(u.resolve(m,d,_,null,{shadow:!1}))===!1)return{code:"object.with",context:{main:c.key.key,mainWithLabel:s.keysToLabels(i,c.key.key),peer:u.key,peerWithLabel:s.keysToLabels(i,u.key)}}},without(i,c,m,d,_){const v=s.isPresent(c.options);for(const u of c.peers)if(v(u.resolve(m,d,_,null,{shadow:!1})))return{code:"object.without",context:{main:c.key.key,mainWithLabel:s.keysToLabels(i,c.key.key),peer:u.key,peerWithLabel:s.keysToLabels(i,u.key)}}},xor(i,c,m,d,_){const v=[],u=s.isPresent(c.options);for(const y of c.peers)u(y.resolve(m,d,_,null,{shadow:!1}))&&v.push(y.key);if(v.length===1)return;const h={peers:c.paths,peersWithLabels:s.keysToLabels(i,c.paths)};return v.length===0?{code:"object.missing",context:h}:(h.present=v,h.presentWithLabels=s.keysToLabels(i,v),{code:"object.xor",context:h})}},s.keysToLabels=function(i,c){return Array.isArray(c)?c.map(m=>i.$_mapLabels(m)):i.$_mapLabels(c)},s.isPresent=function(i){return typeof i.isPresent=="function"?i.isPresent:c=>c!==void 0},s.rename=function(i,c,m,d,_){const v={};for(const u of i.$_terms.renames){const h=[],y=typeof u.from!="string";if(y)for(const w in c){if(c[w]===void 0&&u.options.ignoreUndefined||w===u.to)continue;const x=u.from.exec(w);x&&h.push({from:w,to:u.to,match:x})}else!Object.prototype.hasOwnProperty.call(c,u.from)||c[u.from]===void 0&&u.options.ignoreUndefined||h.push(u);for(const w of h){const x=w.from;let j=w.to;if(j instanceof o&&(j=j.render(c,m,d,w.match)),x!==j){if(!u.options.multiple&&v[j]&&(_.push(i.$_createError("object.rename.multiple",c,{from:x,to:j,pattern:y},m,d)),d.abortEarly)||Object.prototype.hasOwnProperty.call(c,j)&&!u.options.override&&!v[j]&&(_.push(i.$_createError("object.rename.override",c,{from:x,to:j,pattern:y},m,d)),d.abortEarly))return!1;c[x]===void 0?delete c[j]:c[j]=c[x],v[j]=!0,u.options.alias||delete c[x]}}}return!0},s.unknown=function(i,c,m,d,_,v){if(i.$_terms.patterns){let u=!1;const h=i.$_terms.patterns.map(w=>{if(w.matches)return u=!0,[]}),y=[c,..._.ancestors];for(const w of m){const x=c[w],j=[..._.path,w];for(let S=0;S<i.$_terms.patterns.length;++S){const R=i.$_terms.patterns[S];if(R.regex){const L=R.regex.test(w);if(_.mainstay.tracer.debug(_,"rule",`pattern.${S}`,L?"pass":"error"),!L)continue}else if(!R.schema.$_match(w,_.nest(R.schema,`pattern.${S}`),v))continue;m.delete(w);const O=_.localize(j,y,{schema:R.rule,key:w}),D=R.rule.$_validate(x,O,v);if(D.errors){if(v.abortEarly)return{value:c,errors:D.errors};d.push(...D.errors)}if(R.matches&&h[S].push(w),c[w]=D.value,!R.fallthrough)break}}if(u)for(let w=0;w<h.length;++w){const x=h[w];if(!x)continue;const j=i.$_terms.patterns[w].matches,S=_.localize(_.path,y,j),R=j.$_validate(x,S,v);if(R.errors){const O=r.details(R.errors,{override:!1});O.matches=x;const D=i.$_createError("object.pattern.match",c,O,_,v);if(v.abortEarly)return{value:c,errors:D};d.push(D)}}}if(m.size&&(i.$_terms.keys||i.$_terms.patterns)){if(v.stripUnknown&&!i._flags.unknown||v.skipFunctions){const u=!(!v.stripUnknown||v.stripUnknown!==!0&&!v.stripUnknown.objects);for(const h of m)u?(delete c[h],m.delete(h)):typeof c[h]=="function"&&m.delete(h)}if(!n.default(i._flags.unknown,v.allowUnknown))for(const u of m){const h=_.localize([..._.path,u],[]),y=i.$_createError("object.unknown",c[u],{child:u},h,v,{flags:!1});if(v.abortEarly)return{value:c,errors:y};d.push(y)}}},s.Dependency=class{constructor(i,c,m,d,_){this.rel=i,this.key=c,this.peers=m,this.paths=d,this.options=_}describe(){const i={rel:this.rel,peers:this.paths};return this.key!==null&&(i.key=this.key.key),this.peers[0].separator!=="."&&(i.options={...i.options,separator:this.peers[0].separator}),this.options.isPresent&&(i.options={...i.options,isPresent:this.options.isPresent}),i}},s.Keys=class extends Array{concat(i){const c=this.slice(),m=new Map;for(let d=0;d<c.length;++d)m.set(c[d].key,d);for(const d of i){const _=d.key,v=m.get(_);v!==void 0?c[v]={key:_,schema:c[v].schema.concat(d.schema)}:c.push(d)}return c}}},8785:(k,$,b)=>{const l=b(375),p=b(8068),g=b(8160),f=b(3292),t=b(6354),n={};k.exports=p.extend({type:"link",properties:{schemaChain:!0},terms:{link:{init:null,manifest:"single",register:!1}},args:(a,r)=>a.ref(r),validate(a,{schema:r,state:e,prefs:o}){l(r.$_terms.link,"Uninitialized link schema");const s=n.generate(r,a,e,o),i=r.$_terms.link[0].ref;return s.$_validate(a,e.nest(s,`link:${i.display}:${s.type}`),o)},generate:(a,r,e,o)=>n.generate(a,r,e,o),rules:{ref:{method(a){l(!this.$_terms.link,"Cannot reinitialize schema"),a=f.ref(a),l(a.type==="value"||a.type==="local","Invalid reference type:",a.type),l(a.type==="local"||a.ancestor==="root"||a.ancestor>0,"Link cannot reference itself");const r=this.clone();return r.$_terms.link=[{ref:a}],r}},relative:{method(a=!0){return this.$_setFlag("relative",a)}}},overrides:{concat(a){l(this.$_terms.link,"Uninitialized link schema"),l(g.isSchema(a),"Invalid schema object"),l(a.type!=="link","Cannot merge type link with another link");const r=this.clone();return r.$_terms.whens||(r.$_terms.whens=[]),r.$_terms.whens.push({concat:a}),r.$_mutateRebuild()}},manifest:{build:(a,r)=>(l(r.link,"Invalid link description missing link"),a.ref(r.link))}}),n.generate=function(a,r,e,o){let s=e.mainstay.links.get(a);if(s)return s._generate(r,e,o).schema;const i=a.$_terms.link[0].ref,{perspective:c,path:m}=n.perspective(i,e);n.assert(c,"which is outside of schema boundaries",i,a,e,o);try{s=m.length?c.$_reach(m):c}catch{n.assert(!1,"to non-existing schema",i,a,e,o)}return n.assert(s.type!=="link","which is another link",i,a,e,o),a._flags.relative||e.mainstay.links.set(a,s),s._generate(r,e,o).schema},n.perspective=function(a,r){if(a.type==="local"){for(const{schema:e,key:o}of r.schemas){if((e._flags.id||o)===a.path[0])return{perspective:e,path:a.path.slice(1)};if(e.$_terms.shared){for(const s of e.$_terms.shared)if(s._flags.id===a.path[0])return{perspective:s,path:a.path.slice(1)}}}return{perspective:null,path:null}}return a.ancestor==="root"?{perspective:r.schemas[r.schemas.length-1].schema,path:a.path}:{perspective:r.schemas[a.ancestor]&&r.schemas[a.ancestor].schema,path:a.path}},n.assert=function(a,r,e,o,s,i){a||l(!1,`"${t.label(o._flags,s,i)}" contains link reference "${e.display}" ${r}`)}},3832:(k,$,b)=>{const l=b(375),p=b(8068),g=b(8160),f={numberRx:/^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,precisionRx:/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,exponentialPartRegex:/[eE][+-]?\d+$/,leadingSignAndZerosRegex:/^[+-]?(0*)?/,dotRegex:/\./,trailingZerosRegex:/0+$/,decimalPlaces(t){const n=t.toString(),a=n.indexOf("."),r=n.indexOf("e");return(a<0?0:(r<0?n.length:r)-a-1)+(r<0?0:Math.max(0,-parseInt(n.slice(r+1))))}};k.exports=p.extend({type:"number",flags:{unsafe:{default:!1}},coerce:{from:"string",method(t,{schema:n,error:a}){if(!t.match(f.numberRx))return;t=t.trim();const r={value:parseFloat(t)};if(r.value===0&&(r.value=0),!n._flags.unsafe)if(t.match(/e/i)){if(f.extractSignificantDigits(t)!==f.extractSignificantDigits(String(r.value)))return r.errors=a("number.unsafe"),r}else{const e=r.value.toString();if(e.match(/e/i))return r;if(e!==f.normalizeDecimal(t))return r.errors=a("number.unsafe"),r}return r}},validate(t,{schema:n,error:a,prefs:r}){if(t===1/0||t===-1/0)return{value:t,errors:a("number.infinity")};if(!g.isNumber(t))return{value:t,errors:a("number.base")};const e={value:t};if(r.convert){const o=n.$_getRule("precision");if(o){const s=Math.pow(10,o.args.limit);e.value=Math.round(e.value*s)/s}}return e.value===0&&(e.value=0),!n._flags.unsafe&&(t>Number.MAX_SAFE_INTEGER||t<Number.MIN_SAFE_INTEGER)&&(e.errors=a("number.unsafe")),e},rules:{compare:{method:!1,validate:(t,n,{limit:a},{name:r,operator:e,args:o})=>g.compare(t,a,e)?t:n.error("number."+r,{limit:o.limit,value:t}),args:[{name:"limit",ref:!0,assert:g.isNumber,message:"must be a number"}]},greater:{method(t){return this.$_addRule({name:"greater",method:"compare",args:{limit:t},operator:">"})}},integer:{method(){return this.$_addRule("integer")},validate:(t,n)=>Math.trunc(t)-t==0?t:n.error("number.integer")},less:{method(t){return this.$_addRule({name:"less",method:"compare",args:{limit:t},operator:"<"})}},max:{method(t){return this.$_addRule({name:"max",method:"compare",args:{limit:t},operator:"<="})}},min:{method(t){return this.$_addRule({name:"min",method:"compare",args:{limit:t},operator:">="})}},multiple:{method(t){const n=typeof t=="number"?f.decimalPlaces(t):null,a=Math.pow(10,n);return this.$_addRule({name:"multiple",args:{base:t,baseDecimalPlace:n,pfactor:a}})},validate:(t,n,{base:a,baseDecimalPlace:r,pfactor:e},o)=>f.decimalPlaces(t)>r?n.error("number.multiple",{multiple:o.args.base,value:t}):Math.round(e*t)%Math.round(e*a)==0?t:n.error("number.multiple",{multiple:o.args.base,value:t}),args:[{name:"base",ref:!0,assert:t=>typeof t=="number"&&isFinite(t)&&t>0,message:"must be a positive number"},"baseDecimalPlace","pfactor"],multi:!0},negative:{method(){return this.sign("negative")}},port:{method(){return this.$_addRule("port")},validate:(t,n)=>Number.isSafeInteger(t)&&t>=0&&t<=65535?t:n.error("number.port")},positive:{method(){return this.sign("positive")}},precision:{method(t){return l(Number.isSafeInteger(t),"limit must be an integer"),this.$_addRule({name:"precision",args:{limit:t}})},validate(t,n,{limit:a}){const r=t.toString().match(f.precisionRx);return Math.max((r[1]?r[1].length:0)-(r[2]?parseInt(r[2],10):0),0)<=a?t:n.error("number.precision",{limit:a,value:t})},convert:!0},sign:{method(t){return l(["negative","positive"].includes(t),"Invalid sign",t),this.$_addRule({name:"sign",args:{sign:t}})},validate:(t,n,{sign:a})=>a==="negative"&&t<0||a==="positive"&&t>0?t:n.error(`number.${a}`)},unsafe:{method(t=!0){return l(typeof t=="boolean","enabled must be a boolean"),this.$_setFlag("unsafe",t)}}},cast:{string:{from:t=>typeof t=="number",to:(t,n)=>t.toString()}},messages:{"number.base":"{{#label}} must be a number","number.greater":"{{#label}} must be greater than {{#limit}}","number.infinity":"{{#label}} cannot be infinity","number.integer":"{{#label}} must be an integer","number.less":"{{#label}} must be less than {{#limit}}","number.max":"{{#label}} must be less than or equal to {{#limit}}","number.min":"{{#label}} must be greater than or equal to {{#limit}}","number.multiple":"{{#label}} must be a multiple of {{#multiple}}","number.negative":"{{#label}} must be a negative number","number.port":"{{#label}} must be a valid port","number.positive":"{{#label}} must be a positive number","number.precision":"{{#label}} must have no more than {{#limit}} decimal places","number.unsafe":"{{#label}} must be a safe number"}}),f.extractSignificantDigits=function(t){return t.replace(f.exponentialPartRegex,"").replace(f.dotRegex,"").replace(f.trailingZerosRegex,"").replace(f.leadingSignAndZerosRegex,"")},f.normalizeDecimal=function(t){return(t=t.replace(/^\+/,"").replace(/\.0*$/,"").replace(/^(-?)\.([^\.]*)$/,"$10.$2").replace(/^(-?)0+([0-9])/,"$1$2")).includes(".")&&t.endsWith("0")&&(t=t.replace(/0+$/,"")),t==="-0"?"0":t}},8966:(k,$,b)=>{const l=b(7824);k.exports=l.extend({type:"object",cast:{map:{from:p=>p&&typeof p=="object",to:(p,g)=>new Map(Object.entries(p))}}})},7417:(k,$,b)=>{const l=b(375),p=b(5380),g=b(1745),f=b(9959),t=b(6064),n=b(9926),a=b(5752),r=b(8068),e=b(8160),o={tlds:n instanceof Set&&{tlds:{allow:n,deny:null}},base64Regex:{true:{true:/^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,false:/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/},false:{true:/^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,false:/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/}},dataUriRegex:/^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,hexRegex:{withPrefix:/^0x[0-9a-f]+$/i,withOptionalPrefix:/^(?:0x)?[0-9a-f]+$/i,withoutPrefix:/^[0-9a-f]+$/i},ipRegex:f.regex({cidr:"forbidden"}).regex,isoDurationRegex:/^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,guidBrackets:{"{":"}","[":"]","(":")","":""},guidVersions:{uuidv1:"1",uuidv2:"2",uuidv3:"3",uuidv4:"4",uuidv5:"5",uuidv6:"6",uuidv7:"7",uuidv8:"8"},guidSeparators:new Set([void 0,!0,!1,"-",":"]),normalizationForms:["NFC","NFD","NFKC","NFKD"]};k.exports=r.extend({type:"string",flags:{insensitive:{default:!1},truncate:{default:!1}},terms:{replacements:{init:null}},coerce:{from:"string",method(s,{schema:i,state:c,prefs:m}){const d=i.$_getRule("normalize");d&&(s=s.normalize(d.args.form));const _=i.$_getRule("case");_&&(s=_.args.direction==="upper"?s.toLocaleUpperCase():s.toLocaleLowerCase());const v=i.$_getRule("trim");if(v&&v.args.enabled&&(s=s.trim()),i.$_terms.replacements)for(const h of i.$_terms.replacements)s=s.replace(h.pattern,h.replacement);const u=i.$_getRule("hex");if(u&&u.args.options.byteAligned&&s.length%2!=0&&(s=`0${s}`),i.$_getRule("isoDate")){const h=o.isoDate(s);h&&(s=h)}if(i._flags.truncate){const h=i.$_getRule("max");if(h){let y=h.args.limit;if(e.isResolvable(y)&&(y=y.resolve(s,c,m),!e.limit(y)))return{value:s,errors:i.$_createError("any.ref",y,{ref:h.args.limit,arg:"limit",reason:"must be a positive integer"},c,m)};s=s.slice(0,y)}}return{value:s}}},validate(s,{schema:i,error:c}){if(typeof s!="string")return{value:s,errors:c("string.base")};if(s===""){const m=i.$_getRule("min");return m&&m.args.limit===0?void 0:{value:s,errors:c("string.empty")}}},rules:{alphanum:{method(){return this.$_addRule("alphanum")},validate:(s,i)=>/^[a-zA-Z0-9]+$/.test(s)?s:i.error("string.alphanum")},base64:{method(s={}){return e.assertOptions(s,["paddingRequired","urlSafe"]),s={urlSafe:!1,paddingRequired:!0,...s},l(typeof s.paddingRequired=="boolean","paddingRequired must be boolean"),l(typeof s.urlSafe=="boolean","urlSafe must be boolean"),this.$_addRule({name:"base64",args:{options:s}})},validate:(s,i,{options:c})=>o.base64Regex[c.paddingRequired][c.urlSafe].test(s)?s:i.error("string.base64")},case:{method(s){return l(["lower","upper"].includes(s),"Invalid case:",s),this.$_addRule({name:"case",args:{direction:s}})},validate:(s,i,{direction:c})=>c==="lower"&&s===s.toLocaleLowerCase()||c==="upper"&&s===s.toLocaleUpperCase()?s:i.error(`string.${c}case`),convert:!0},creditCard:{method(){return this.$_addRule("creditCard")},validate(s,i){let c=s.length,m=0,d=1;for(;c--;){const _=s.charAt(c)*d;m+=_-9*(_>9),d^=3}return m>0&&m%10==0?s:i.error("string.creditCard")}},dataUri:{method(s={}){return e.assertOptions(s,["paddingRequired"]),s={paddingRequired:!0,...s},l(typeof s.paddingRequired=="boolean","paddingRequired must be boolean"),this.$_addRule({name:"dataUri",args:{options:s}})},validate(s,i,{options:c}){const m=s.match(o.dataUriRegex);return m&&(!m[2]||m[2]!=="base64"||o.base64Regex[c.paddingRequired].false.test(m[3]))?s:i.error("string.dataUri")}},domain:{method(s){s&&e.assertOptions(s,["allowFullyQualified","allowUnicode","maxDomainSegments","minDomainSegments","tlds"]);const i=o.addressOptions(s);return this.$_addRule({name:"domain",args:{options:s},address:i})},validate:(s,i,c,{address:m})=>p.isValid(s,m)?s:i.error("string.domain")},email:{method(s={}){e.assertOptions(s,["allowFullyQualified","allowUnicode","ignoreLength","maxDomainSegments","minDomainSegments","multiple","separator","tlds"]),l(s.multiple===void 0||typeof s.multiple=="boolean","multiple option must be an boolean");const i=o.addressOptions(s),c=new RegExp(`\\s*[${s.separator?t(s.separator):","}]\\s*`);return this.$_addRule({name:"email",args:{options:s},regex:c,address:i})},validate(s,i,{options:c},{regex:m,address:d}){const _=c.multiple?s.split(m):[s],v=[];for(const u of _)g.isValid(u,d)||v.push(u);return v.length?i.error("string.email",{value:s,invalids:v}):s}},guid:{alias:"uuid",method(s={}){e.assertOptions(s,["version","separator"]);let i="";if(s.version){const d=[].concat(s.version);l(d.length>=1,"version must have at least 1 valid version specified");const _=new Set;for(let v=0;v<d.length;++v){const u=d[v];l(typeof u=="string","version at position "+v+" must be a string");const h=o.guidVersions[u.toLowerCase()];l(h,"version at position "+v+" must be one of "+Object.keys(o.guidVersions).join(", ")),l(!_.has(h),"version at position "+v+" must not be a duplicate"),i+=h,_.add(h)}}l(o.guidSeparators.has(s.separator),'separator must be one of true, false, "-", or ":"');const c=s.separator===void 0?"[:-]?":s.separator===!0?"[:-]":s.separator===!1?"[]?":`\\${s.separator}`,m=new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${c})[0-9A-F]{4}\\2?[${i||"0-9A-F"}][0-9A-F]{3}\\2?[${i?"89AB":"0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`,"i");return this.$_addRule({name:"guid",args:{options:s},regex:m})},validate(s,i,c,{regex:m}){const d=m.exec(s);return d?o.guidBrackets[d[1]]!==d[d.length-1]?i.error("string.guid"):s:i.error("string.guid")}},hex:{method(s={}){return e.assertOptions(s,["byteAligned","prefix"]),s={byteAligned:!1,prefix:!1,...s},l(typeof s.byteAligned=="boolean","byteAligned must be boolean"),l(typeof s.prefix=="boolean"||s.prefix==="optional",'prefix must be boolean or "optional"'),this.$_addRule({name:"hex",args:{options:s}})},validate:(s,i,{options:c})=>(c.prefix==="optional"?o.hexRegex.withOptionalPrefix:c.prefix===!0?o.hexRegex.withPrefix:o.hexRegex.withoutPrefix).test(s)?c.byteAligned&&s.length%2!=0?i.error("string.hexAlign"):s:i.error("string.hex")},hostname:{method(){return this.$_addRule("hostname")},validate:(s,i)=>p.isValid(s,{minDomainSegments:1})||o.ipRegex.test(s)?s:i.error("string.hostname")},insensitive:{method(){return this.$_setFlag("insensitive",!0)}},ip:{method(s={}){e.assertOptions(s,["cidr","version"]);const{cidr:i,versions:c,regex:m}=f.regex(s),d=s.version?c:void 0;return this.$_addRule({name:"ip",args:{options:{cidr:i,version:d}},regex:m})},validate:(s,i,{options:c},{regex:m})=>m.test(s)?s:c.version?i.error("string.ipVersion",{value:s,cidr:c.cidr,version:c.version}):i.error("string.ip",{value:s,cidr:c.cidr})},isoDate:{method(){return this.$_addRule("isoDate")},validate:(s,{error:i})=>o.isoDate(s)?s:i("string.isoDate")},isoDuration:{method(){return this.$_addRule("isoDuration")},validate:(s,i)=>o.isoDurationRegex.test(s)?s:i.error("string.isoDuration")},length:{method(s,i){return o.length(this,"length",s,"=",i)},validate(s,i,{limit:c,encoding:m},{name:d,operator:_,args:v}){const u=!m&&s.length;return e.compare(u,c,_)?s:i.error("string."+d,{limit:v.limit,value:s,encoding:m})},args:[{name:"limit",ref:!0,assert:e.limit,message:"must be a positive integer"},"encoding"]},lowercase:{method(){return this.case("lower")}},max:{method(s,i){return o.length(this,"max",s,"<=",i)},args:["limit","encoding"]},min:{method(s,i){return o.length(this,"min",s,">=",i)},args:["limit","encoding"]},normalize:{method(s="NFC"){return l(o.normalizationForms.includes(s),"normalization form must be one of "+o.normalizationForms.join(", ")),this.$_addRule({name:"normalize",args:{form:s}})},validate:(s,{error:i},{form:c})=>s===s.normalize(c)?s:i("string.normalize",{value:s,form:c}),convert:!0},pattern:{alias:"regex",method(s,i={}){l(s instanceof RegExp,"regex must be a RegExp"),l(!s.flags.includes("g")&&!s.flags.includes("y"),"regex should not use global or sticky mode"),typeof i=="string"&&(i={name:i}),e.assertOptions(i,["invert","name"]);const c=["string.pattern",i.invert?".invert":"",i.name?".name":".base"].join("");return this.$_addRule({name:"pattern",args:{regex:s,options:i},errorCode:c})},validate:(s,i,{regex:c,options:m},{errorCode:d})=>c.test(s)^m.invert?s:i.error(d,{name:m.name,regex:c,value:s}),args:["regex","options"],multi:!0},replace:{method(s,i){typeof s=="string"&&(s=new RegExp(t(s),"g")),l(s instanceof RegExp,"pattern must be a RegExp"),l(typeof i=="string","replacement must be a String");const c=this.clone();return c.$_terms.replacements||(c.$_terms.replacements=[]),c.$_terms.replacements.push({pattern:s,replacement:i}),c}},token:{method(){return this.$_addRule("token")},validate:(s,i)=>/^\w+$/.test(s)?s:i.error("string.token")},trim:{method(s=!0){return l(typeof s=="boolean","enabled must be a boolean"),this.$_addRule({name:"trim",args:{enabled:s}})},validate:(s,i,{enabled:c})=>c&&s!==s.trim()?i.error("string.trim"):s,convert:!0},truncate:{method(s=!0){return l(typeof s=="boolean","enabled must be a boolean"),this.$_setFlag("truncate",s)}},uppercase:{method(){return this.case("upper")}},uri:{method(s={}){e.assertOptions(s,["allowRelative","allowQuerySquareBrackets","domain","relativeOnly","scheme"]),s.domain&&e.assertOptions(s.domain,["allowFullyQualified","allowUnicode","maxDomainSegments","minDomainSegments","tlds"]);const{regex:i,scheme:c}=a.regex(s),m=s.domain?o.addressOptions(s.domain):null;return this.$_addRule({name:"uri",args:{options:s},regex:i,domain:m,scheme:c})},validate(s,i,{options:c},{regex:m,domain:d,scheme:_}){if(["http:/","https:/"].includes(s))return i.error("string.uri");const v=m.exec(s);if(v){const u=v[1]||v[2];return!d||c.allowRelative&&!u||p.isValid(u,d)?s:i.error("string.domain",{value:u})}return c.relativeOnly?i.error("string.uriRelativeOnly"):c.scheme?i.error("string.uriCustomScheme",{scheme:_,value:s}):i.error("string.uri")}}},manifest:{build(s,i){if(i.replacements)for(const{pattern:c,replacement:m}of i.replacements)s=s.replace(c,m);return s}},messages:{"string.alphanum":"{{#label}} must only contain alpha-numeric characters","string.base":"{{#label}} must be a string","string.base64":"{{#label}} must be a valid base64 string","string.creditCard":"{{#label}} must be a credit card","string.dataUri":"{{#label}} must be a valid dataUri string","string.domain":"{{#label}} must contain a valid domain name","string.email":"{{#label}} must be a valid email","string.empty":"{{#label}} is not allowed to be empty","string.guid":"{{#label}} must be a valid GUID","string.hex":"{{#label}} must only contain hexadecimal characters","string.hexAlign":"{{#label}} hex decoded representation must be byte aligned","string.hostname":"{{#label}} must be a valid hostname","string.ip":"{{#label}} must be a valid ip address with a {{#cidr}} CIDR","string.ipVersion":"{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR","string.isoDate":"{{#label}} must be in iso format","string.isoDuration":"{{#label}} must be a valid ISO 8601 duration","string.length":"{{#label}} length must be {{#limit}} characters long","string.lowercase":"{{#label}} must only contain lowercase characters","string.max":"{{#label}} length must be less than or equal to {{#limit}} characters long","string.min":"{{#label}} length must be at least {{#limit}} characters long","string.normalize":"{{#label}} must be unicode normalized in the {{#form}} form","string.token":"{{#label}} must only contain alpha-numeric and underscore characters","string.pattern.base":"{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}","string.pattern.name":"{{#label}} with value {:[.]} fails to match the {{#name}} pattern","string.pattern.invert.base":"{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}","string.pattern.invert.name":"{{#label}} with value {:[.]} matches the inverted {{#name}} pattern","string.trim":"{{#label}} must not have leading or trailing whitespace","string.uri":"{{#label}} must be a valid uri","string.uriCustomScheme":"{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern","string.uriRelativeOnly":"{{#label}} must be a valid relative uri","string.uppercase":"{{#label}} must only contain uppercase characters"}}),o.addressOptions=function(s){if(!s)return o.tlds||s;if(l(s.minDomainSegments===void 0||Number.isSafeInteger(s.minDomainSegments)&&s.minDomainSegments>0,"minDomainSegments must be a positive integer"),l(s.maxDomainSegments===void 0||Number.isSafeInteger(s.maxDomainSegments)&&s.maxDomainSegments>0,"maxDomainSegments must be a positive integer"),s.tlds===!1)return s;if(s.tlds===!0||s.tlds===void 0)return l(o.tlds,"Built-in TLD list disabled"),Object.assign({},s,o.tlds);l(typeof s.tlds=="object","tlds must be true, false, or an object");const i=s.tlds.deny;if(i)return Array.isArray(i)&&(s=Object.assign({},s,{tlds:{deny:new Set(i)}})),l(s.tlds.deny instanceof Set,"tlds.deny must be an array, Set, or boolean"),l(!s.tlds.allow,"Cannot specify both tlds.allow and tlds.deny lists"),o.validateTlds(s.tlds.deny,"tlds.deny"),s;const c=s.tlds.allow;return c?c===!0?(l(o.tlds,"Built-in TLD list disabled"),Object.assign({},s,o.tlds)):(Array.isArray(c)&&(s=Object.assign({},s,{tlds:{allow:new Set(c)}})),l(s.tlds.allow instanceof Set,"tlds.allow must be an array, Set, or boolean"),o.validateTlds(s.tlds.allow,"tlds.allow"),s):s},o.validateTlds=function(s,i){for(const c of s)l(p.isValid(c,{minDomainSegments:1,maxDomainSegments:1}),`${i} must contain valid top level domain names`)},o.isoDate=function(s){if(!e.isIsoDate(s))return null;/.*T.*[+-]\d\d$/.test(s)&&(s+="00");const i=new Date(s);return isNaN(i.getTime())?null:i.toISOString()},o.length=function(s,i,c,m,d){return l(!d||!1,"Invalid encoding:",d),s.$_addRule({name:i,method:"length",args:{limit:c,encoding:d},operator:m})}},8826:(k,$,b)=>{const l=b(375),p=b(8068),g={};g.Map=class extends Map{slice(){return new g.Map(this)}},k.exports=p.extend({type:"symbol",terms:{map:{init:new g.Map}},coerce:{method(f,{schema:t,error:n}){const a=t.$_terms.map.get(f);return a&&(f=a),t._flags.only&&typeof f!="symbol"?{value:f,errors:n("symbol.map",{map:t.$_terms.map})}:{value:f}}},validate(f,{error:t}){if(typeof f!="symbol")return{value:f,errors:t("symbol.base")}},rules:{map:{method(f){f&&!f[Symbol.iterator]&&typeof f=="object"&&(f=Object.entries(f)),l(f&&f[Symbol.iterator],"Iterable must be an iterable or object");const t=this.clone(),n=[];for(const a of f){l(a&&a[Symbol.iterator],"Entry must be an iterable");const[r,e]=a;l(typeof r!="object"&&typeof r!="function"&&typeof r!="symbol","Key must not be of type object, function, or Symbol"),l(typeof e=="symbol","Value must be a Symbol"),t.$_terms.map.set(r,e),n.push(e)}return t.valid(...n)}}},manifest:{build:(f,t)=>(t.map&&(f=f.map(t.map)),f)},messages:{"symbol.base":"{{#label}} must be a symbol","symbol.map":"{{#label}} must be one of {{#map}}"}})},8863:(k,$,b)=>{const l=b(375),p=b(8571),g=b(738),f=b(9621),t=b(8160),n=b(6354),a=b(493),r={result:Symbol("result")};$.entry=function(e,o,s){let i=t.defaults;s&&(l(s.warnings===void 0,"Cannot override warnings preference in synchronous validation"),l(s.artifacts===void 0,"Cannot override artifacts preference in synchronous validation"),i=t.preferences(t.defaults,s));const c=r.entry(e,o,i);l(!c.mainstay.externals.length,"Schema with external rules must use validateAsync()");const m={value:c.value};return c.error&&(m.error=c.error),c.mainstay.warnings.length&&(m.warning=n.details(c.mainstay.warnings)),c.mainstay.debug&&(m.debug=c.mainstay.debug),c.mainstay.artifacts&&(m.artifacts=c.mainstay.artifacts),m},$.entryAsync=async function(e,o,s){let i=t.defaults;s&&(i=t.preferences(t.defaults,s));const c=r.entry(e,o,i),m=c.mainstay;if(c.error)throw m.debug&&(c.error.debug=m.debug),c.error;if(m.externals.length){let _=c.value;const v=[];for(const u of m.externals){const h=u.state.path,y=u.schema.type==="link"?m.links.get(u.schema):null;let w,x,j=_;const S=h.length?[_]:[],R=h.length?f(e,h):e;if(h.length){w=h[h.length-1];let O=_;for(const D of h.slice(0,-1))O=O[D],S.unshift(O);x=S[0],j=x[w]}try{const O=(L,z)=>(y||u.schema).$_createError(L,j,z,u.state,i),D=await u.method(j,{schema:u.schema,linked:y,state:u.state,prefs:s,original:R,error:O,errorsArray:r.errorsArray,warn:(L,z)=>m.warnings.push((y||u.schema).$_createError(L,j,z,u.state,i)),message:(L,z)=>(y||u.schema).$_createError("external",j,z,u.state,i,{messages:L})});if(D===void 0||D===j)continue;if(D instanceof n.Report){if(m.tracer.log(u.schema,u.state,"rule","external","error"),v.push(D),i.abortEarly)break;continue}if(Array.isArray(D)&&D[t.symbols.errors]){if(m.tracer.log(u.schema,u.state,"rule","external","error"),v.push(...D),i.abortEarly)break;continue}x?(m.tracer.value(u.state,"rule",j,D,"external"),x[w]=D):(m.tracer.value(u.state,"rule",_,D,"external"),_=D)}catch(O){throw i.errors.label&&(O.message+=` (${u.label})`),O}}if(c.value=_,v.length)throw c.error=n.process(v,e,i),m.debug&&(c.error.debug=m.debug),c.error}if(!i.warnings&&!i.debug&&!i.artifacts)return c.value;const d={value:c.value};return m.warnings.length&&(d.warning=n.details(m.warnings)),m.debug&&(d.debug=m.debug),m.artifacts&&(d.artifacts=m.artifacts),d},r.Mainstay=class{constructor(e,o,s){this.externals=[],this.warnings=[],this.tracer=e,this.debug=o,this.links=s,this.shadow=null,this.artifacts=null,this._snapshots=[]}snapshot(){this._snapshots.push({externals:this.externals.slice(),warnings:this.warnings.slice()})}restore(){const e=this._snapshots.pop();this.externals=e.externals,this.warnings=e.warnings}commit(){this._snapshots.pop()}},r.entry=function(e,o,s){const{tracer:i,cleanup:c}=r.tracer(o,s),m=s.debug?[]:null,d=o._ids._schemaChain?new Map:null,_=new r.Mainstay(i,m,d),v=o._ids._schemaChain?[{schema:o}]:null,u=new a([],[],{mainstay:_,schemas:v}),h=$.validate(e,o,u,s);c&&o.$_root.untrace();const y=n.process(h.errors,e,s);return{value:h.value,error:y,mainstay:_}},r.tracer=function(e,o){return e.$_root._tracer?{tracer:e.$_root._tracer._register(e)}:o.debug?(l(e.$_root.trace,"Debug mode not supported"),{tracer:e.$_root.trace()._register(e),cleanup:!0}):{tracer:r.ignore}},$.validate=function(e,o,s,i,c={}){if(o.$_terms.whens&&(o=o._generate(e,s,i).schema),o._preferences&&(i=r.prefs(o,i)),o._cache&&i.cache){const y=o._cache.get(e);if(s.mainstay.tracer.debug(s,"validate","cached",!!y),y)return y}const m=(y,w,x)=>o.$_createError(y,e,w,x||s,i),d={original:e,prefs:i,schema:o,state:s,error:m,errorsArray:r.errorsArray,warn:(y,w,x)=>s.mainstay.warnings.push(m(y,w,x)),message:(y,w)=>o.$_createError("custom",e,w,s,i,{messages:y})};s.mainstay.tracer.entry(o,s);const _=o._definition;if(_.prepare&&e!==void 0&&i.convert){const y=_.prepare(e,d);if(y){if(s.mainstay.tracer.value(s,"prepare",e,y.value),y.errors)return r.finalize(y.value,[].concat(y.errors),d);e=y.value}}if(_.coerce&&e!==void 0&&i.convert&&(!_.coerce.from||_.coerce.from.includes(typeof e))){const y=_.coerce.method(e,d);if(y){if(s.mainstay.tracer.value(s,"coerced",e,y.value),y.errors)return r.finalize(y.value,[].concat(y.errors),d);e=y.value}}const v=o._flags.empty;v&&v.$_match(r.trim(e,o),s.nest(v),t.defaults)&&(s.mainstay.tracer.value(s,"empty",e,void 0),e=void 0);const u=c.presence||o._flags.presence||(o._flags._endedSwitch?null:i.presence);if(e===void 0){if(u==="forbidden")return r.finalize(e,null,d);if(u==="required")return r.finalize(e,[o.$_createError("any.required",e,null,s,i)],d);if(u==="optional"){if(o._flags.default!==t.symbols.deepDefault)return r.finalize(e,null,d);s.mainstay.tracer.value(s,"default",e,{}),e={}}}else if(u==="forbidden")return r.finalize(e,[o.$_createError("any.unknown",e,null,s,i)],d);const h=[];if(o._valids){const y=o._valids.get(e,s,i,o._flags.insensitive);if(y)return i.convert&&(s.mainstay.tracer.value(s,"valids",e,y.value),e=y.value),s.mainstay.tracer.filter(o,s,"valid",y),r.finalize(e,null,d);if(o._flags.only){const w=o.$_createError("any.only",e,{valids:o._valids.values({display:!0})},s,i);if(i.abortEarly)return r.finalize(e,[w],d);h.push(w)}}if(o._invalids){const y=o._invalids.get(e,s,i,o._flags.insensitive);if(y){s.mainstay.tracer.filter(o,s,"invalid",y);const w=o.$_createError("any.invalid",e,{invalids:o._invalids.values({display:!0})},s,i);if(i.abortEarly)return r.finalize(e,[w],d);h.push(w)}}if(_.validate){const y=_.validate(e,d);if(y&&(s.mainstay.tracer.value(s,"base",e,y.value),e=y.value,y.errors)){if(!Array.isArray(y.errors))return h.push(y.errors),r.finalize(e,h,d);if(y.errors.length)return h.push(...y.errors),r.finalize(e,h,d)}}return o._rules.length?r.rules(e,h,d):r.finalize(e,h,d)},r.rules=function(e,o,s){const{schema:i,state:c,prefs:m}=s;for(const d of i._rules){const _=i._definition.rules[d.method];if(_.convert&&m.convert){c.mainstay.tracer.log(i,c,"rule",d.name,"full");continue}let v,u=d.args;if(d._resolve.length){u=Object.assign({},u);for(const y of d._resolve){const w=_.argsByName.get(y),x=u[y].resolve(e,c,m),j=w.normalize?w.normalize(x):x,S=t.validateArg(j,null,w);if(S){v=i.$_createError("any.ref",x,{arg:y,ref:u[y],reason:S},c,m);break}u[y]=j}}v=v||_.validate(e,s,u,d);const h=r.rule(v,d);if(h.errors){if(c.mainstay.tracer.log(i,c,"rule",d.name,"error"),d.warn){c.mainstay.warnings.push(...h.errors);continue}if(m.abortEarly)return r.finalize(e,h.errors,s);o.push(...h.errors)}else c.mainstay.tracer.log(i,c,"rule",d.name,"pass"),c.mainstay.tracer.value(c,"rule",e,h.value,d.name),e=h.value}return r.finalize(e,o,s)},r.rule=function(e,o){return e instanceof n.Report?(r.error(e,o),{errors:[e],value:null}):Array.isArray(e)&&e[t.symbols.errors]?(e.forEach(s=>r.error(s,o)),{errors:e,value:null}):{errors:null,value:e}},r.error=function(e,o){return o.message&&e._setTemplate(o.message),e},r.finalize=function(e,o,s){o=o||[];const{schema:i,state:c,prefs:m}=s;if(o.length){const _=r.default("failover",void 0,o,s);_!==void 0&&(c.mainstay.tracer.value(c,"failover",e,_),e=_,o=[])}if(o.length&&i._flags.error)if(typeof i._flags.error=="function"){o=i._flags.error(o),Array.isArray(o)||(o=[o]);for(const _ of o)l(_ instanceof Error||_ instanceof n.Report,"error() must return an Error object")}else o=[i._flags.error];if(e===void 0){const _=r.default("default",e,o,s);c.mainstay.tracer.value(c,"default",e,_),e=_}if(i._flags.cast&&e!==void 0){const _=i._definition.cast[i._flags.cast];if(_.from(e)){const v=_.to(e,s);c.mainstay.tracer.value(c,"cast",e,v,i._flags.cast),e=v}}if(i.$_terms.externals&&m.externals&&m._externals!==!1)for(const{method:_}of i.$_terms.externals)c.mainstay.externals.push({method:_,schema:i,state:c,label:n.label(i._flags,c,m)});const d={value:e,errors:o.length?o:null};return i._flags.result&&(d.value=i._flags.result==="strip"?void 0:s.original,c.mainstay.tracer.value(c,i._flags.result,e,d.value),c.shadow(e,i._flags.result)),i._cache&&m.cache!==!1&&!i._refs.length&&i._cache.set(s.original,d),e===void 0||d.errors||i._flags.artifact===void 0||(c.mainstay.artifacts=c.mainstay.artifacts||new Map,c.mainstay.artifacts.has(i._flags.artifact)||c.mainstay.artifacts.set(i._flags.artifact,[]),c.mainstay.artifacts.get(i._flags.artifact).push(c.path)),d},r.prefs=function(e,o){const s=o===t.defaults;return s&&e._preferences[t.symbols.prefs]?e._preferences[t.symbols.prefs]:(o=t.preferences(o,e._preferences),s&&(e._preferences[t.symbols.prefs]=o),o)},r.default=function(e,o,s,i){const{schema:c,state:m,prefs:d}=i,_=c._flags[e];if(d.noDefaults||_===void 0)return o;if(m.mainstay.tracer.log(c,m,"rule",e,"full"),!_)return _;if(typeof _=="function"){const v=_.length?[p(m.ancestors[0]),i]:[];try{return _(...v)}catch(u){return void s.push(c.$_createError(`any.${e}`,null,{error:u},m,d))}}return typeof _!="object"?_:_[t.symbols.literal]?_.literal:t.isResolvable(_)?_.resolve(o,m,d):p(_)},r.trim=function(e,o){if(typeof e!="string")return e;const s=o.$_getRule("trim");return s&&s.args.enabled?e.trim():e},r.ignore={active:!1,debug:g,entry:g,filter:g,log:g,resolve:g,value:g},r.errorsArray=function(){const e=[];return e[t.symbols.errors]=!0,e}},2036:(k,$,b)=>{const l=b(375),p=b(9474),g=b(8160),f={};k.exports=f.Values=class{constructor(t,n){this._values=new Set(t),this._refs=new Set(n),this._lowercase=f.lowercases(t),this._override=!1}get length(){return this._values.size+this._refs.size}add(t,n){g.isResolvable(t)?this._refs.has(t)||(this._refs.add(t),n&&n.register(t)):this.has(t,null,null,!1)||(this._values.add(t),typeof t=="string"&&this._lowercase.set(t.toLowerCase(),t))}static merge(t,n,a){if(t=t||new f.Values,n){if(n._override)return n.clone();for(const r of[...n._values,...n._refs])t.add(r)}if(a)for(const r of[...a._values,...a._refs])t.remove(r);return t.length?t:null}remove(t){g.isResolvable(t)?this._refs.delete(t):(this._values.delete(t),typeof t=="string"&&this._lowercase.delete(t.toLowerCase()))}has(t,n,a,r){return!!this.get(t,n,a,r)}get(t,n,a,r){if(!this.length)return!1;if(this._values.has(t))return{value:t};if(typeof t=="string"&&t&&r){const e=this._lowercase.get(t.toLowerCase());if(e)return{value:e}}if(!this._refs.size&&typeof t!="object")return!1;if(typeof t=="object"){for(const e of this._values)if(p(e,t))return{value:e}}if(n)for(const e of this._refs){const o=e.resolve(t,n,a,null,{in:!0});if(o===void 0)continue;const s=e.in&&typeof o=="object"?Array.isArray(o)?o:Object.keys(o):[o];for(const i of s)if(typeof i==typeof t){if(r&&t&&typeof t=="string"){if(i.toLowerCase()===t.toLowerCase())return{value:i,ref:e}}else if(p(i,t))return{value:i,ref:e}}}return!1}override(){this._override=!0}values(t){if(t&&t.display){const n=[];for(const a of[...this._values,...this._refs])a!==void 0&&n.push(a);return n}return Array.from([...this._values,...this._refs])}clone(){const t=new f.Values(this._values,this._refs);return t._override=this._override,t}concat(t){l(!t._override,"Cannot concat override set of values");const n=new f.Values([...this._values,...t._values],[...this._refs,...t._refs]);return n._override=this._override,n}describe(){const t=[];this._override&&t.push({override:!0});for(const n of this._values.values())t.push(n&&typeof n=="object"?{value:n}:n);for(const n of this._refs.values())t.push(n.describe());return t}},f.Values.prototype[g.symbols.values]=!0,f.Values.prototype.slice=f.Values.prototype.clone,f.lowercases=function(t){const n=new Map;if(t)for(const a of t)typeof a=="string"&&n.set(a.toLowerCase(),a);return n}},978:(k,$,b)=>{const l=b(375),p=b(8571),g=b(1687),f=b(9621),t={};k.exports=function(n,a,r={}){if(l(n&&typeof n=="object","Invalid defaults value: must be an object"),l(!a||a===!0||typeof a=="object","Invalid source value: must be true, falsy or an object"),l(typeof r=="object","Invalid options: must be an object"),!a)return null;if(r.shallow)return t.applyToDefaultsWithShallow(n,a,r);const e=p(n);if(a===!0)return e;const o=r.nullOverride!==void 0&&r.nullOverride;return g(e,a,{nullOverride:o,mergeArrays:!1})},t.applyToDefaultsWithShallow=function(n,a,r){const e=r.shallow;l(Array.isArray(e),"Invalid keys");const o=new Map,s=a===!0?null:new Set;for(let m of e){m=Array.isArray(m)?m:m.split(".");const d=f(n,m);d&&typeof d=="object"?o.set(d,s&&f(a,m)||d):s&&s.add(m)}const i=p(n,{},o);if(!s)return i;for(const m of s)t.reachCopy(i,a,m);const c=r.nullOverride!==void 0&&r.nullOverride;return g(i,a,{nullOverride:c,mergeArrays:!1})},t.reachCopy=function(n,a,r){for(const s of r){if(!(s in a))return;const i=a[s];if(typeof i!="object"||i===null)return;a=i}const e=a;let o=n;for(let s=0;s<r.length-1;++s){const i=r[s];typeof o[i]!="object"&&(o[i]={}),o=o[i]}o[r[r.length-1]]=e}},375:(k,$,b)=>{const l=b(7916);k.exports=function(p,...g){if(!p)throw g.length===1&&g[0]instanceof Error?g[0]:new l(g)}},8571:(k,$,b)=>{const l=b(9621),p=b(4277),g=b(7043),f={needsProtoHack:new Set([p.set,p.map,p.weakSet,p.weakMap])};k.exports=f.clone=function(t,n={},a=null){if(typeof t!="object"||t===null)return t;let r=f.clone,e=a;if(n.shallow){if(n.shallow!==!0)return f.cloneWithShallow(t,n);r=c=>c}else if(e){const c=e.get(t);if(c)return c}else e=new Map;const o=p.getInternalProto(t);if(o===p.buffer)return!1;if(o===p.date)return new Date(t.getTime());if(o===p.regex)return new RegExp(t);const s=f.base(t,o,n);if(s===t)return t;if(e&&e.set(t,s),o===p.set)for(const c of t)s.add(r(c,n,e));else if(o===p.map)for(const[c,m]of t)s.set(c,r(m,n,e));const i=g.keys(t,n);for(const c of i){if(c==="__proto__")continue;if(o===p.array&&c==="length"){s.length=t.length;continue}const m=Object.getOwnPropertyDescriptor(t,c);m?m.get||m.set?Object.defineProperty(s,c,m):m.enumerable?s[c]=r(t[c],n,e):Object.defineProperty(s,c,{enumerable:!1,writable:!0,configurable:!0,value:r(t[c],n,e)}):Object.defineProperty(s,c,{enumerable:!0,writable:!0,configurable:!0,value:r(t[c],n,e)})}return s},f.cloneWithShallow=function(t,n){const a=n.shallow;(n=Object.assign({},n)).shallow=!1;const r=new Map;for(const e of a){const o=l(t,e);typeof o!="object"&&typeof o!="function"||r.set(o,o)}return f.clone(t,n,r)},f.base=function(t,n,a){if(a.prototype===!1)return f.needsProtoHack.has(n)?new n.constructor:n===p.array?[]:{};const r=Object.getPrototypeOf(t);if(r&&r.isImmutable)return t;if(n===p.array){const e=[];return r!==n&&Object.setPrototypeOf(e,r),e}if(f.needsProtoHack.has(n)){const e=new r.constructor;return r!==n&&Object.setPrototypeOf(e,r),e}return Object.create(r)}},9474:(k,$,b)=>{const l=b(4277),p={mismatched:null};k.exports=function(g,f,t){return t=Object.assign({prototype:!0},t),!!p.isDeepEqual(g,f,t,[])},p.isDeepEqual=function(g,f,t,n){if(g===f)return g!==0||1/g==1/f;const a=typeof g;if(a!==typeof f||g===null||f===null)return!1;if(a==="function"){if(!t.deepFunction||g.toString()!==f.toString())return!1}else if(a!=="object")return g!=g&&f!=f;const r=p.getSharedType(g,f,!!t.prototype);switch(r){case l.buffer:return!1;case l.promise:return g===f;case l.regex:return g.toString()===f.toString();case p.mismatched:return!1}for(let e=n.length-1;e>=0;--e)if(n[e].isSame(g,f))return!0;n.push(new p.SeenEntry(g,f));try{return!!p.isDeepEqualObj(r,g,f,t,n)}finally{n.pop()}},p.getSharedType=function(g,f,t){if(t)return Object.getPrototypeOf(g)!==Object.getPrototypeOf(f)?p.mismatched:l.getInternalProto(g);const n=l.getInternalProto(g);return n!==l.getInternalProto(f)?p.mismatched:n},p.valueOf=function(g){const f=g.valueOf;if(f===void 0)return g;try{return f.call(g)}catch(t){return t}},p.hasOwnEnumerableProperty=function(g,f){return Object.prototype.propertyIsEnumerable.call(g,f)},p.isSetSimpleEqual=function(g,f){for(const t of Set.prototype.values.call(g))if(!Set.prototype.has.call(f,t))return!1;return!0},p.isDeepEqualObj=function(g,f,t,n,a){const{isDeepEqual:r,valueOf:e,hasOwnEnumerableProperty:o}=p,{keys:s,getOwnPropertySymbols:i}=Object;if(g===l.array){if(!n.part){if(f.length!==t.length)return!1;for(let v=0;v<f.length;++v)if(!r(f[v],t[v],n,a))return!1;return!0}for(const v of f)for(const u of t)if(r(v,u,n,a))return!0}else if(g===l.set){if(f.size!==t.size)return!1;if(!p.isSetSimpleEqual(f,t)){const v=new Set(Set.prototype.values.call(t));for(const u of Set.prototype.values.call(f)){if(v.delete(u))continue;let h=!1;for(const y of v)if(r(u,y,n,a)){v.delete(y),h=!0;break}if(!h)return!1}}}else if(g===l.map){if(f.size!==t.size)return!1;for(const[v,u]of Map.prototype.entries.call(f))if(u===void 0&&!Map.prototype.has.call(t,v)||!r(u,Map.prototype.get.call(t,v),n,a))return!1}else if(g===l.error&&(f.name!==t.name||f.message!==t.message))return!1;const c=e(f),m=e(t);if((f!==c||t!==m)&&!r(c,m,n,a))return!1;const d=s(f);if(!n.part&&d.length!==s(t).length&&!n.skip)return!1;let _=0;for(const v of d)if(n.skip&&n.skip.includes(v))t[v]===void 0&&++_;else if(!o(t,v)||!r(f[v],t[v],n,a))return!1;if(!n.part&&d.length-_!==s(t).length)return!1;if(n.symbols!==!1){const v=i(f),u=new Set(i(t));for(const h of v){if(!n.skip||!n.skip.includes(h)){if(o(f,h)){if(!o(t,h)||!r(f[h],t[h],n,a))return!1}else if(o(t,h))return!1}u.delete(h)}for(const h of u)if(o(t,h))return!1}return!0},p.SeenEntry=class{constructor(g,f){this.obj=g,this.ref=f}isSame(g,f){return this.obj===g&&this.ref===f}}},7916:(k,$,b)=>{const l=b(8761);k.exports=class extends Error{constructor(p){super(p.filter(g=>g!=="").map(g=>typeof g=="string"?g:g instanceof Error?g.message:l(g)).join(" ")||"Unknown error"),typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,$.assert)}}},5277:k=>{const $={};k.exports=function(b){if(!b)return"";let l="";for(let p=0;p<b.length;++p){const g=b.charCodeAt(p);$.isSafe(g)?l+=b[p]:l+=$.escapeHtmlChar(g)}return l},$.escapeHtmlChar=function(b){return $.namedHtml.get(b)||(b>=256?"&#"+b+";":`&#x${b.toString(16).padStart(2,"0")};`)},$.isSafe=function(b){return $.safeCharCodes.has(b)},$.namedHtml=new Map([[38,"&amp;"],[60,"&lt;"],[62,"&gt;"],[34,"&quot;"],[160,"&nbsp;"],[162,"&cent;"],[163,"&pound;"],[164,"&curren;"],[169,"&copy;"],[174,"&reg;"]]),$.safeCharCodes=function(){const b=new Set;for(let l=32;l<123;++l)(l>=97||l>=65&&l<=90||l>=48&&l<=57||l===32||l===46||l===44||l===45||l===58||l===95)&&b.add(l);return b}()},6064:k=>{k.exports=function($){return $.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g,"\\$&")}},738:k=>{k.exports=function(){}},1687:(k,$,b)=>{const l=b(375),p=b(8571),g=b(7043),f={};k.exports=f.merge=function(t,n,a){if(l(t&&typeof t=="object","Invalid target value: must be an object"),l(n==null||typeof n=="object","Invalid source value: must be null, undefined, or an object"),!n)return t;if(a=Object.assign({nullOverride:!0,mergeArrays:!0},a),Array.isArray(n)){l(Array.isArray(t),"Cannot merge array onto an object"),a.mergeArrays||(t.length=0);for(let e=0;e<n.length;++e)t.push(p(n[e],{symbols:a.symbols}));return t}const r=g.keys(n,a);for(let e=0;e<r.length;++e){const o=r[e];if(o==="__proto__"||!Object.prototype.propertyIsEnumerable.call(n,o))continue;const s=n[o];if(s&&typeof s=="object"){if(t[o]===s)continue;!t[o]||typeof t[o]!="object"||Array.isArray(t[o])!==Array.isArray(s)||s instanceof Date||s instanceof RegExp?t[o]=p(s,{symbols:a.symbols}):f.merge(t[o],s,a)}else(s!=null||a.nullOverride)&&(t[o]=s)}return t}},9621:(k,$,b)=>{const l=b(375),p={};k.exports=function(g,f,t){if(f===!1||f==null)return g;typeof(t=t||{})=="string"&&(t={separator:t});const n=Array.isArray(f);l(!n||!t.separator,"Separator option is not valid for array-based chain");const a=n?f:f.split(t.separator||".");let r=g;for(let e=0;e<a.length;++e){let o=a[e];const s=t.iterables&&p.iterables(r);if(Array.isArray(r)||s==="set"){const i=Number(o);Number.isInteger(i)&&(o=i<0?r.length+i:i)}if(!r||typeof r=="function"&&t.functions===!1||!s&&r[o]===void 0){l(!t.strict||e+1===a.length,"Missing segment",o,"in reach path ",f),l(typeof r=="object"||t.functions===!0||typeof r!="function","Invalid segment",o,"in reach path ",f),r=t.default;break}r=s?s==="set"?[...r][o]:r.get(o):r[o]}return r},p.iterables=function(g){return g instanceof Set?"set":g instanceof Map?"map":void 0}},8761:k=>{k.exports=function(...$){try{return JSON.stringify(...$)}catch(b){return"[Cannot display object: "+b.message+"]"}}},4277:(k,$)=>{const b={};$=k.exports={array:Array.prototype,buffer:!1,date:Date.prototype,error:Error.prototype,generic:Object.prototype,map:Map.prototype,promise:Promise.prototype,regex:RegExp.prototype,set:Set.prototype,weakMap:WeakMap.prototype,weakSet:WeakSet.prototype},b.typeMap=new Map([["[object Error]",$.error],["[object Map]",$.map],["[object Promise]",$.promise],["[object Set]",$.set],["[object WeakMap]",$.weakMap],["[object WeakSet]",$.weakSet]]),$.getInternalProto=function(l){if(Array.isArray(l))return $.array;if(l instanceof Date)return $.date;if(l instanceof RegExp)return $.regex;if(l instanceof Error)return $.error;const p=Object.prototype.toString.call(l);return b.typeMap.get(p)||$.generic}},7043:(k,$)=>{$.keys=function(b,l={}){return l.symbols!==!1?Reflect.ownKeys(b):Object.getOwnPropertyNames(b)}},3652:(k,$,b)=>{const l=b(375),p={};$.Sorter=class{constructor(){this._items=[],this.nodes=[]}add(g,f){const t=[].concat((f=f||{}).before||[]),n=[].concat(f.after||[]),a=f.group||"?",r=f.sort||0;l(!t.includes(a),`Item cannot come before itself: ${a}`),l(!t.includes("?"),"Item cannot come before unassociated items"),l(!n.includes(a),`Item cannot come after itself: ${a}`),l(!n.includes("?"),"Item cannot come after unassociated items"),Array.isArray(g)||(g=[g]);for(const e of g){const o={seq:this._items.length,sort:r,before:t,after:n,group:a,node:e};this._items.push(o)}if(!f.manual){const e=this._sort();l(e,"item",a!=="?"?`added into group ${a}`:"","created a dependencies error")}return this.nodes}merge(g){Array.isArray(g)||(g=[g]);for(const t of g)if(t)for(const n of t._items)this._items.push(Object.assign({},n));this._items.sort(p.mergeSort);for(let t=0;t<this._items.length;++t)this._items[t].seq=t;const f=this._sort();return l(f,"merge created a dependencies error"),this.nodes}sort(){const g=this._sort();return l(g,"sort created a dependencies error"),this.nodes}_sort(){const g={},f=Object.create(null),t=Object.create(null);for(const o of this._items){const s=o.seq,i=o.group;t[i]=t[i]||[],t[i].push(s),g[s]=o.before;for(const c of o.after)f[c]=f[c]||[],f[c].push(s)}for(const o in g){const s=[];for(const i in g[o]){const c=g[o][i];t[c]=t[c]||[],s.push(...t[c])}g[o]=s}for(const o in f)if(t[o])for(const s of t[o])g[s].push(...f[o]);const n={};for(const o in g){const s=g[o];for(const i of s)n[i]=n[i]||[],n[i].push(o)}const a={},r=[];for(let o=0;o<this._items.length;++o){let s=o;if(n[o]){s=null;for(let i=0;i<this._items.length;++i){if(a[i]===!0)continue;n[i]||(n[i]=[]);const c=n[i].length;let m=0;for(let d=0;d<c;++d)a[n[i][d]]&&++m;if(m===c){s=i;break}}}s!==null&&(a[s]=!0,r.push(s))}if(r.length!==this._items.length)return!1;const e={};for(const o of this._items)e[o.seq]=o;this._items=[],this.nodes=[];for(const o of r){const s=e[o];this.nodes.push(s.node),this._items.push(s)}return!0}},p.mergeSort=(g,f)=>g.sort===f.sort?0:g.sort<f.sort?-1:1},5380:(k,$,b)=>{const l=b(443),p=b(2178),g={minDomainSegments:2,nonAsciiRx:/[^\x00-\x7f]/,domainControlRx:/[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,tldSegmentRx:/^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,domainSegmentRx:/^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,URL:l.URL||URL};$.analyze=function(f,t={}){if(!f)return p.code("DOMAIN_NON_EMPTY_STRING");if(typeof f!="string")throw new Error("Invalid input: domain must be a string");if(f.length>256)return p.code("DOMAIN_TOO_LONG");if(g.nonAsciiRx.test(f)){if(t.allowUnicode===!1)return p.code("DOMAIN_INVALID_UNICODE_CHARS");f=f.normalize("NFC")}if(g.domainControlRx.test(f))return p.code("DOMAIN_INVALID_CHARS");f=g.punycode(f),t.allowFullyQualified&&f[f.length-1]==="."&&(f=f.slice(0,-1));const n=t.minDomainSegments||g.minDomainSegments,a=f.split(".");if(a.length<n)return p.code("DOMAIN_SEGMENTS_COUNT");if(t.maxDomainSegments&&a.length>t.maxDomainSegments)return p.code("DOMAIN_SEGMENTS_COUNT_MAX");const r=t.tlds;if(r){const e=a[a.length-1].toLowerCase();if(r.deny&&r.deny.has(e)||r.allow&&!r.allow.has(e))return p.code("DOMAIN_FORBIDDEN_TLDS")}for(let e=0;e<a.length;++e){const o=a[e];if(!o.length)return p.code("DOMAIN_EMPTY_SEGMENT");if(o.length>63)return p.code("DOMAIN_LONG_SEGMENT");if(e<a.length-1){if(!g.domainSegmentRx.test(o))return p.code("DOMAIN_INVALID_CHARS")}else if(!g.tldSegmentRx.test(o))return p.code("DOMAIN_INVALID_TLDS_CHARS")}return null},$.isValid=function(f,t){return!$.analyze(f,t)},g.punycode=function(f){f.includes("%")&&(f=f.replace(/%/g,"%25"));try{return new g.URL(`http://${f}`).host}catch{return f}}},1745:(k,$,b)=>{const l=b(9848),p=b(5380),g=b(2178),f={nonAsciiRx:/[^\x00-\x7f]/,encoder:new(l.TextEncoder||TextEncoder)};$.analyze=function(t,n){return f.email(t,n)},$.isValid=function(t,n){return!f.email(t,n)},f.email=function(t,n={}){if(typeof t!="string")throw new Error("Invalid input: email must be a string");if(!t)return g.code("EMPTY_STRING");const a=!f.nonAsciiRx.test(t);if(!a){if(n.allowUnicode===!1)return g.code("FORBIDDEN_UNICODE");t=t.normalize("NFC")}const r=t.split("@");if(r.length!==2)return r.length>2?g.code("MULTIPLE_AT_CHAR"):g.code("MISSING_AT_CHAR");const[e,o]=r;if(!e)return g.code("EMPTY_LOCAL");if(!n.ignoreLength){if(t.length>254)return g.code("ADDRESS_TOO_LONG");if(f.encoder.encode(e).length>64)return g.code("LOCAL_TOO_LONG")}return f.local(e,a)||p.analyze(o,n)},f.local=function(t,n){const a=t.split(".");for(const r of a){if(!r.length)return g.code("EMPTY_LOCAL_SEGMENT");if(n){if(!f.atextRx.test(r))return g.code("INVALID_LOCAL_CHARS")}else for(const e of r){if(f.atextRx.test(e))continue;const o=f.binary(e);if(!f.atomRx.test(o))return g.code("INVALID_LOCAL_CHARS")}}},f.binary=function(t){return Array.from(f.encoder.encode(t)).map(n=>String.fromCharCode(n)).join("")},f.atextRx=/^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/,f.atomRx=new RegExp(["(?:[\\xc2-\\xdf][\\x80-\\xbf])","(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})","(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"].join("|"))},2178:(k,$)=>{$.codes={EMPTY_STRING:"Address must be a non-empty string",FORBIDDEN_UNICODE:"Address contains forbidden Unicode characters",MULTIPLE_AT_CHAR:"Address cannot contain more than one @ character",MISSING_AT_CHAR:"Address must contain one @ character",EMPTY_LOCAL:"Address local part cannot be empty",ADDRESS_TOO_LONG:"Address too long",LOCAL_TOO_LONG:"Address local part too long",EMPTY_LOCAL_SEGMENT:"Address local part contains empty dot-separated segment",INVALID_LOCAL_CHARS:"Address local part contains invalid character",DOMAIN_NON_EMPTY_STRING:"Domain must be a non-empty string",DOMAIN_TOO_LONG:"Domain too long",DOMAIN_INVALID_UNICODE_CHARS:"Domain contains forbidden Unicode characters",DOMAIN_INVALID_CHARS:"Domain contains invalid character",DOMAIN_INVALID_TLDS_CHARS:"Domain contains invalid tld character",DOMAIN_SEGMENTS_COUNT:"Domain lacks the minimum required number of segments",DOMAIN_SEGMENTS_COUNT_MAX:"Domain contains too many segments",DOMAIN_FORBIDDEN_TLDS:"Domain uses forbidden TLD",DOMAIN_EMPTY_SEGMENT:"Domain contains empty dot-separated segment",DOMAIN_LONG_SEGMENT:"Domain contains dot-separated segment that is too long"},$.code=function(b){return{code:b,error:$.codes[b]}}},9959:(k,$,b)=>{const l=b(375),p=b(5752);$.regex=function(g={}){l(g.cidr===void 0||typeof g.cidr=="string","options.cidr must be a string");const f=g.cidr?g.cidr.toLowerCase():"optional";l(["required","optional","forbidden"].includes(f),"options.cidr must be one of required, optional, forbidden"),l(g.version===void 0||typeof g.version=="string"||Array.isArray(g.version),"options.version must be a string or an array of string");let t=g.version||["ipv4","ipv6","ipvfuture"];Array.isArray(t)||(t=[t]),l(t.length>=1,"options.version must have at least 1 version specified");for(let r=0;r<t.length;++r)l(typeof t[r]=="string","options.version must only contain strings"),t[r]=t[r].toLowerCase(),l(["ipv4","ipv6","ipvfuture"].includes(t[r]),"options.version contains unknown version "+t[r]+" - must be one of ipv4, ipv6, ipvfuture");t=Array.from(new Set(t));const n=`(?:${t.map(r=>{if(f==="forbidden")return p.ip[r];const e=`\\/${r==="ipv4"?p.ip.v4Cidr:p.ip.v6Cidr}`;return f==="required"?`${p.ip[r]}${e}`:`${p.ip[r]}(?:${e})?`}).join("|")})`,a=new RegExp(`^${n}$`);return{cidr:f,versions:t,regex:a,raw:n}}},5752:(k,$,b)=>{const l=b(375),p=b(6064),g={generate:function(){const f={},t="\\dA-Fa-f",n="["+t+"]",a="\\w-\\.~",r="!\\$&'\\(\\)\\*\\+,;=",e="%"+t,o=a+e+r+":@",s="["+o+"]",i="(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";f.ipv4address="(?:"+i+"\\.){3}"+i;const c=n+"{1,4}",m="(?:"+c+":"+c+"|"+f.ipv4address+")",d="(?:"+c+":){6}"+m,_="::(?:"+c+":){5}"+m,v="(?:"+c+")?::(?:"+c+":){4}"+m,u="(?:(?:"+c+":){0,1}"+c+")?::(?:"+c+":){3}"+m,h="(?:(?:"+c+":){0,2}"+c+")?::(?:"+c+":){2}"+m,y="(?:(?:"+c+":){0,3}"+c+")?::"+c+":"+m,w="(?:(?:"+c+":){0,4}"+c+")?::"+m,x="(?:(?:"+c+":){0,5}"+c+")?::"+c,j="(?:(?:"+c+":){0,6}"+c+")?::";f.ipv4Cidr="(?:\\d|[1-2]\\d|3[0-2])",f.ipv6Cidr="(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])",f.ipv6address="(?:"+d+"|"+_+"|"+v+"|"+u+"|"+h+"|"+y+"|"+w+"|"+x+"|"+j+")",f.ipvFuture="v"+n+"+\\.["+a+r+":]+",f.scheme="[a-zA-Z][a-zA-Z\\d+-\\.]*",f.schemeRegex=new RegExp(f.scheme);const S="["+a+e+r+":]*",R="["+a+e+r+"]{1,255}",O="(?:\\[(?:"+f.ipv6address+"|"+f.ipvFuture+")\\]|"+f.ipv4address+"|"+R+")",D="(?:"+S+"@)?"+O+"(?::\\d*)?",L="(?:"+S+"@)?("+O+")(?::\\d*)?",z=s+"*",M=s+"+",E="(?:\\/"+z+")*",T="\\/(?:"+M+E+")?",P=M+E,Y="["+a+e+r+"@]+"+E,H="(?:\\/\\/\\/"+z+E+")";return f.hierPart="(?:(?:\\/\\/"+D+E+")|"+T+"|"+P+"|"+H+")",f.hierPartCapture="(?:(?:\\/\\/"+L+E+")|"+T+"|"+P+")",f.relativeRef="(?:(?:\\/\\/"+D+E+")|"+T+"|"+Y+"|)",f.relativeRefCapture="(?:(?:\\/\\/"+L+E+")|"+T+"|"+Y+"|)",f.query="["+o+"\\/\\?]*(?=#|$)",f.queryWithSquareBrackets="["+o+"\\[\\]\\/\\?]*(?=#|$)",f.fragment="["+o+"\\/\\?]*",f}};g.rfc3986=g.generate(),$.ip={v4Cidr:g.rfc3986.ipv4Cidr,v6Cidr:g.rfc3986.ipv6Cidr,ipv4:g.rfc3986.ipv4address,ipv6:g.rfc3986.ipv6address,ipvfuture:g.rfc3986.ipvFuture},g.createRegex=function(f){const t=g.rfc3986,n="(?:\\?"+(f.allowQuerySquareBrackets?t.queryWithSquareBrackets:t.query)+")?(?:#"+t.fragment+")?",a=f.domain?t.relativeRefCapture:t.relativeRef;if(f.relativeOnly)return g.wrap(a+n);let r="";if(f.scheme){l(f.scheme instanceof RegExp||typeof f.scheme=="string"||Array.isArray(f.scheme),"scheme must be a RegExp, String, or Array");const s=[].concat(f.scheme);l(s.length>=1,"scheme must have at least 1 scheme specified");const i=[];for(let c=0;c<s.length;++c){const m=s[c];l(m instanceof RegExp||typeof m=="string","scheme at position "+c+" must be a RegExp or String"),m instanceof RegExp?i.push(m.source.toString()):(l(t.schemeRegex.test(m),"scheme at position "+c+" must be a valid scheme"),i.push(p(m)))}r=i.join("|")}const e="(?:"+(r?"(?:"+r+")":t.scheme)+":"+(f.domain?t.hierPartCapture:t.hierPart)+")",o=f.allowRelative?"(?:"+e+"|"+a+")":e;return g.wrap(o+n,r)},g.wrap=function(f,t){return{raw:f=`(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${f}`,regex:new RegExp(`^${f}$`),scheme:t}},g.uriRegex=g.createRegex({}),$.regex=function(f={}){return f.scheme||f.allowRelative||f.relativeOnly||f.allowQuerySquareBrackets||f.domain?g.createRegex(f):g.uriRegex}},1447:(k,$)=>{const b={operators:["!","^","*","/","%","+","-","<","<=",">",">=","==","!=","&&","||","??"],operatorCharacters:["!","^","*","/","%","+","-","<","=",">","&","|","?"],operatorsOrder:[["^"],["*","/","%"],["+","-"],["<","<=",">",">="],["==","!="],["&&"],["||","??"]],operatorsPrefix:["!","n"],literals:{'"':'"',"`":"`","'":"'","[":"]"},numberRx:/^(?:[0-9]*(\.[0-9]*)?){1}$/,tokenRx:/^[\w\$\#\.\@\:\{\}]+$/,symbol:Symbol("formula"),settings:Symbol("settings")};$.Parser=class{constructor(l,p={}){if(!p[b.settings]&&p.constants)for(const g in p.constants){const f=p.constants[g];if(f!==null&&!["boolean","number","string"].includes(typeof f))throw new Error(`Formula constant ${g} contains invalid ${typeof f} value type`)}this.settings=p[b.settings]?p:Object.assign({[b.settings]:!0,constants:{},functions:{}},p),this.single=null,this._parts=null,this._parse(l)}_parse(l){let p=[],g="",f=0,t=!1;const n=r=>{if(f)throw new Error("Formula missing closing parenthesis");const e=p.length?p[p.length-1]:null;if(t||g||r){if(e&&e.type==="reference"&&r===")")return e.type="function",e.value=this._subFormula(g,e.value),void(g="");if(r===")"){const o=new $.Parser(g,this.settings);p.push({type:"segment",value:o})}else if(t){if(t==="]")return p.push({type:"reference",value:g}),void(g="");p.push({type:"literal",value:g})}else if(b.operatorCharacters.includes(g))e&&e.type==="operator"&&b.operators.includes(e.value+g)?e.value+=g:p.push({type:"operator",value:g});else if(g.match(b.numberRx))p.push({type:"constant",value:parseFloat(g)});else if(this.settings.constants[g]!==void 0)p.push({type:"constant",value:this.settings.constants[g]});else{if(!g.match(b.tokenRx))throw new Error(`Formula contains invalid token: ${g}`);p.push({type:"reference",value:g})}g=""}};for(const r of l)t?r===t?(n(),t=!1):g+=r:f?r==="("?(g+=r,++f):r===")"?(--f,f?g+=r:n(r)):g+=r:r in b.literals?t=b.literals[r]:r==="("?(n(),++f):b.operatorCharacters.includes(r)?(n(),g=r,n()):r!==" "?g+=r:n();n(),p=p.map((r,e)=>r.type!=="operator"||r.value!=="-"||e&&p[e-1].type!=="operator"?r:{type:"operator",value:"n"});let a=!1;for(const r of p){if(r.type==="operator"){if(b.operatorsPrefix.includes(r.value))continue;if(!a)throw new Error("Formula contains an operator in invalid position");if(!b.operators.includes(r.value))throw new Error(`Formula contains an unknown operator ${r.value}`)}else if(a)throw new Error("Formula missing expected operator");a=!a}if(!a)throw new Error("Formula contains invalid trailing operator");p.length===1&&["reference","literal","constant"].includes(p[0].type)&&(this.single={type:p[0].type==="reference"?"reference":"value",value:p[0].value}),this._parts=p.map(r=>{if(r.type==="operator")return b.operatorsPrefix.includes(r.value)?r:r.value;if(r.type!=="reference")return r.value;if(this.settings.tokenRx&&!this.settings.tokenRx.test(r.value))throw new Error(`Formula contains invalid reference ${r.value}`);return this.settings.reference?this.settings.reference(r.value):b.reference(r.value)})}_subFormula(l,p){const g=this.settings.functions[p];if(typeof g!="function")throw new Error(`Formula contains unknown function ${p}`);let f=[];if(l){let t="",n=0,a=!1;const r=()=>{if(!t)throw new Error(`Formula contains function ${p} with invalid arguments ${l}`);f.push(t),t=""};for(let e=0;e<l.length;++e){const o=l[e];a?(t+=o,o===a&&(a=!1)):o in b.literals&&!n?(t+=o,a=b.literals[o]):o!==","||n?(t+=o,o==="("?++n:o===")"&&--n):r()}r()}return f=f.map(t=>new $.Parser(t,this.settings)),function(t){const n=[];for(const a of f)n.push(a.evaluate(t));return g.call(t,...n)}}evaluate(l){const p=this._parts.slice();for(let g=p.length-2;g>=0;--g){const f=p[g];if(f&&f.type==="operator"){const t=p[g+1];p.splice(g+1,1);const n=b.evaluate(t,l);p[g]=b.single(f.value,n)}}return b.operatorsOrder.forEach(g=>{for(let f=1;f<p.length-1;)if(g.includes(p[f])){const t=p[f],n=b.evaluate(p[f-1],l),a=b.evaluate(p[f+1],l);p.splice(f,2);const r=b.calculate(t,n,a);p[f-1]=r===0?0:r}else f+=2}),b.evaluate(p[0],l)}},$.Parser.prototype[b.symbol]=!0,b.reference=function(l){return function(p){return p&&p[l]!==void 0?p[l]:null}},b.evaluate=function(l,p){return l===null?null:typeof l=="function"?l(p):l[b.symbol]?l.evaluate(p):l},b.single=function(l,p){if(l==="!")return!p;const g=-p;return g===0?0:g},b.calculate=function(l,p,g){if(l==="??")return b.exists(p)?p:g;if(typeof p=="string"||typeof g=="string"){if(l==="+")return(p=b.exists(p)?p:"")+(b.exists(g)?g:"")}else switch(l){case"^":return Math.pow(p,g);case"*":return p*g;case"/":return p/g;case"%":return p%g;case"+":return p+g;case"-":return p-g}switch(l){case"<":return p<g;case"<=":return p<=g;case">":return p>g;case">=":return p>=g;case"==":return p===g;case"!=":return p!==g;case"&&":return p&&g;case"||":return p||g}return null},b.exists=function(l){return l!=null}},9926:()=>{},5688:()=>{},9708:()=>{},1152:()=>{},443:()=>{},9848:()=>{},5934:k=>{k.exports=JSON.parse('{"version":"17.12.2"}')}},I={},function k($){var b=I[$];if(b!==void 0)return b.exports;var l=I[$]={exports:{}};return C[$](l,l.exports,k),l.exports}(5107);var C,I})})(ee);var U=ee.exports;const de=A=>{const N=U.string().pattern(/^[0-9]{10}$/).required();try{return U.assert(A,N),!0}catch{return!1}},pe=A=>{const N=U.string().pattern(/^[0-9]{13}$/).required();try{return U.assert(A,N),!0}catch{return!1}},ge=A=>{const N=U.string().pattern(/^[0-9]+$/).required();try{return U.assert(A,N),!0}catch{return!1}},K=(A,N)=>F(A,N,!0).isValid(),xe=()=>{const[A,N]=V.useState(F().format("YYYY-MM-DD HH:mm:ss")),[C,I]=V.useState([]);F.extend(he),F.extend(fe),F.extend(ce);const k=F.tz.guess(),$=l=>{N(l.target.value)},b=()=>{N(F().format("YYYY-MM-DD HH:mm:ss"))};return V.useEffect(()=>{if(A==null||A==="")return;let l;if(de(A)){const p=Number.parseInt(A,10);l=F.unix(p)}else if(pe(A)){const p=Number.parseInt(A,10);l=F(p)}else if(ge(A)){const p=Number.parseInt(A,10);l=F.unix(p)}else K(A,"YYYY-MM-DD HH:mm:ss")?l=F(A,"YYYY-MM-DD HH:mm:ss").tz(k):K(A,"YYYY-MM-DD")?l=F(A,"YYYY-MM-DD 00:00:00"):l=F(A);console.log(l.toISOString()),I([{tag:"Unix timestamp (Second)",value:l.unix().toString()},{tag:"Timestamp (Millisecond)",value:l.valueOf().toString()},{tag:"ISO 8601",value:l.toISOString()},{tag:"ISO 9075",value:l.format("YYYY-MM-DD HH:mm:ss")},{tag:"RFC 3339",value:l.format("YYYY-MM-DDTHH:mm:ss.SSSZ")},{tag:"RFC 7231",value:l.format("dddd, MMMM D, YYYY h:mm A")}])},[A,k]),q.jsx(te,{title:!1,className:"pt-4",children:q.jsxs(re,{className:"mx-auto max-w-screen-sm",children:[q.jsx("div",{children:q.jsxs(se.Compact,{style:{width:"100%"},children:[q.jsx(ne,{value:A,onChange:$,placeholder:"请输入 10 位数字（秒）、13 位数字（毫秒）或者 YYYY-MM-DD HH:mm:ss 格式字符串",showCount:!0}),q.jsx(ae,{icon:q.jsx(ie,{icon:"material-symbols:refresh"}),onClick:b})]})}),q.jsx("div",{className:"mt-8",children:C.map(l=>q.jsx(oe,{...l},l.tag))})]})})};export{xe as Component};
//# sourceMappingURL=page-Dqmn85Z9.js.map
